"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RNSignerClientParamsSchema = exports.RNSignerClient = void 0;
require("./utils/buffer-polyfill.js");
require("./utils/mmkv-localstorage-polyfill.js");
var _signer = require("@account-kit/signer");
var _reactNativeInappbrowserReborn = require("react-native-inappbrowser-reborn");
var _zod = require("zod");
var _errors = require("./errors.js");
var _NativeTEKStamper = _interopRequireDefault(require("./NativeTEKStamper.js"));
var _parseUrlParams = require("./utils/parseUrlParams.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/* eslint-disable import/extensions */

const RNSignerClientParamsSchema = exports.RNSignerClientParamsSchema = _zod.z.object({
  connection: _zod.z.custom(),
  rootOrgId: _zod.z.string().optional(),
  oauthCallbackUrl: _zod.z.string().optional().default("https://signer.alchemy.com/callback")
});
// TODO: need to emit events
class RNSignerClient extends _signer.BaseSignerClient {
  stamper = _NativeTEKStamper.default;
  validAuthenticatingTypes = ["email", "otp", "oauth"];
  constructor(params) {
    const {
      connection,
      rootOrgId,
      oauthCallbackUrl
    } = RNSignerClientParamsSchema.parse(params);
    super({
      stamper: _NativeTEKStamper.default,
      rootOrgId: rootOrgId ?? "24c1acf5-810f-41e0-a503-d5d13fa8e830",
      connection
    });
    this.oauthCallbackUrl = oauthCallbackUrl;
  }
  async submitOtpCode(args) {
    this.eventEmitter.emit("authenticating", {
      type: "otpVerify"
    });
    const publicKey = await this.stamper.init();
    const {
      credentialBundle
    } = await this.request("/v1/otp", {
      ...args,
      targetPublicKey: publicKey
    });
    return {
      bundle: credentialBundle
    };
  }
  async createAccount(params) {
    if (params.type !== "email") {
      throw new Error("Only email account creation is supported");
    }
    this.eventEmitter.emit("authenticating", {
      type: "email"
    });
    const {
      email,
      expirationSeconds
    } = params;
    const publicKey = await this.stamper.init();
    const response = await this.request("/v1/signup", {
      email,
      emailMode: params.emailMode,
      targetPublicKey: publicKey,
      expirationSeconds,
      redirectParams: params.redirectParams?.toString()
    });
    return response;
  }
  async initEmailAuth(params) {
    this.eventEmitter.emit("authenticating", {
      type: "email"
    });
    let targetPublicKey = await this.stamper.init();
    const response = await this.request("/v1/auth", {
      email: params.email,
      emailMode: params.emailMode,
      targetPublicKey
    });
    return response;
  }
  async completeAuthWithBundle(params) {
    if (!this.validAuthenticatingTypes.includes(params.authenticatingType)) {
      throw new Error("Unsupported authenticating type");
    }
    this.eventEmitter.emit("authenticating", {
      type: params.authenticatingType
    });
    await this.stamper.init();
    const result = await this.stamper.injectCredentialBundle(params.bundle);
    if (!result) {
      throw new Error("Failed to inject credential bundle");
    }
    const user = await this.whoami(params.orgId, params.idToken);
    this.eventEmitter.emit(params.connectedEventName, user, params.bundle);
    return user;
  }
  oauthWithRedirect = async args => {
    // Ensure the In-App Browser required for authentication is available
    if (!(await _reactNativeInappbrowserReborn.InAppBrowser.isAvailable())) {
      throw new _errors.InAppBrowserUnavailableError();
    }
    this.eventEmitter.emit("authenticating", {
      type: "oauth"
    });
    const oauthParams = args;
    const turnkeyPublicKey = await this.stamper.init();
    const oauthCallbackUrl = this.oauthCallbackUrl;
    const oauthConfig = await this.getOauthConfig();
    const providerUrl = await this.getOauthProviderUrl({
      oauthParams,
      turnkeyPublicKey,
      oauthCallbackUrl,
      oauthConfig,
      usesRelativeUrl: false
    });
    const redirectUrl = args.redirectUrl;
    const res = await _reactNativeInappbrowserReborn.InAppBrowser.openAuth(providerUrl, redirectUrl);
    if (res.type !== "success" || !res.url) {
      throw new _signer.OauthFailedError("An error occured completing your request");
    }
    const authResult = (0, _parseUrlParams.parseSearchParams)(res.url);
    const bundle = authResult["alchemy-bundle"] ?? "";
    const orgId = authResult["alchemy-org-id"] ?? "";
    const idToken = authResult["alchemy-id-token"] ?? "";
    const isSignup = authResult["alchemy-is-signup"];
    const error = authResult["alchemy-error"];
    if (bundle && orgId && idToken) {
      const user = await this.completeAuthWithBundle({
        bundle,
        orgId,
        connectedEventName: "connectedOauth",
        idToken,
        authenticatingType: "oauth"
      });
      if (isSignup) {
        this.eventEmitter.emit("newUserSignup");
      }
      return user;
    }

    // Throw the Alchemy error if available, otherwise throw a generic error.
    throw new _signer.OauthFailedError(error ?? "An error occured completing your request");
  };
  oauthWithPopup(_args) {
    throw new Error("Method not implemented");
  }
  async disconnect() {
    this.user = undefined;
    this.stamper.clear();
    await this.stamper.init();
  }
  exportWallet(_params) {
    throw new Error("Method not implemented.");
  }
  lookupUserWithPasskey(_user) {
    throw new Error("Method not implemented.");
  }
  targetPublicKey() {
    return this.stamper.init();
  }
  getWebAuthnAttestation(_options, _userDetails) {
    throw new Error("Method not implemented.");
  }
  getOauthConfig = async () => {
    const publicKey = await this.stamper.init();
    const nonce = this.getOauthNonce(publicKey);
    return this.request("/v1/prepare-oauth", {
      nonce
    });
  };
}
exports.RNSignerClient = RNSignerClient;
//# sourceMappingURL=client.js.map