import { bypassPaymasterAndData, ChainNotFoundError, deepHexlify, defaultGasEstimator, erc7677Middleware, filterUndefined, isBigNumberish, isMultiplier, noopMiddleware, resolveProperties, } from "@aa-sdk/core";
import { fromHex, isHex } from "viem";
import { alchemyFeeEstimator } from "./feeEstimator.js";
/**
 * Paymaster middleware factory that uses Alchemy's Gas Manager for sponsoring
 * transactions. Adheres to the ERC-7677 standardized communication protocol.
 *
 * @example
 *  ```ts
 * import { sepolia, alchemyGasManagerMiddleware } from "@account-kit/infra";
 * import { http } from "viem";
 *
 * const client = createSmartAccountClient({
 *  transport: http("rpc-url"),
 *  chain: sepolia,
 *  ...alchemyGasManagerMiddleware("policyId")
 * });
 * ```
 *
 * @param {string | string[]} policyId the policyId (or list of policyIds) for Alchemy's gas manager
 * @returns {Pick<ClientMiddlewareConfig, "dummyPaymasterAndData" | "paymasterAndData">} partial client middleware configuration containing `dummyPaymasterAndData` and `paymasterAndData`
 */
export function alchemyGasManagerMiddleware(policyId) {
    return erc7677Middleware({
        context: { policyId: policyId },
    });
}
/**
 * Paymaster middleware factory that uses Alchemy's Gas Manager for sponsoring
 * transactions. Uses Alchemy's custom `alchemy_requestGasAndPaymasterAndData`
 * method instead of conforming to the standard ERC-7677 interface. Note that
 * if you use `createAlchemySmartAccountClient`, this middleware is already
 * used by default and you do not need to manually include it.
 *
 * @example
 *  ```ts twoslash
 * import { sepolia, alchemy, alchemyGasAndPaymasterAndDataMiddleware } from "@account-kit/infra";
 * import { createSmartAccountClient } from "@aa-sdk/core";
 *
 * const client = createSmartAccountClient({
 *  transport: alchemy({ apiKey: "your-api-key" }),
 *  chain: sepolia,
 *  ...alchemyGasAndPaymasterAndDataMiddleware({
 *    policyId: "policyId",
 *    transport: alchemy({ apiKey: "your-api-key" }),
 *  })
 * });
 * ```
 *
 * @param {AlchemyGasAndPaymasterAndDataMiddlewareParams} params configuration params
 * @param {AlchemyGasAndPaymasterAndDataMiddlewareParams.policyId} params.policyId the policyId for Alchemy's gas manager
 * @param {AlchemyGasAndPaymasterAndDataMiddlewareParams.transport} params.transport fallback transport to use for fee estimation when not using the paymaster
 * @param {AlchemyGasAndPaymasterAndDataMiddlewareParams.gasEstimatorOverride} params.gasEstimatorOverride custom gas estimator middleware
 * @param {AlchemyGasAndPaymasterAndDataMiddlewareParams.feeEstimatorOverride} params.feeEstimatorOverride custom fee estimator middleware
 * @returns {Pick<ClientMiddlewareConfig, "dummyPaymasterAndData" | "paymasterAndData">} partial client middleware configuration containing `dummyPaymasterAndData` and `paymasterAndData`
 */
export function alchemyGasAndPaymasterAndDataMiddleware(params) {
    const { policyId, transport, gasEstimatorOverride, feeEstimatorOverride } = params;
    return {
        dummyPaymasterAndData: async (uo, args) => {
            if (
            // No reason to generate dummy data if we are bypassing the paymaster.
            bypassPaymasterAndData(args.overrides) ||
                // When using alchemy_requestGasAndPaymasterAndData, there is generally no reason to generate dummy
                // data. However, if the gas/feeEstimator is overriden, then this option should be enabled.
                !(gasEstimatorOverride || feeEstimatorOverride)) {
                return noopMiddleware(uo, args);
            }
            // Fall back to the default 7677 dummyPaymasterAndData middleware.
            return alchemyGasManagerMiddleware(policyId).dummyPaymasterAndData(uo, args);
        },
        feeEstimator: (uo, args) => {
            return feeEstimatorOverride
                ? feeEstimatorOverride(uo, args)
                : bypassPaymasterAndData(args.overrides)
                    ? alchemyFeeEstimator(transport)(uo, args)
                    : noopMiddleware(uo, args);
        },
        gasEstimator: (uo, args) => {
            return gasEstimatorOverride
                ? gasEstimatorOverride(uo, args)
                : bypassPaymasterAndData(args.overrides)
                    ? defaultGasEstimator(args.client)(uo, args)
                    : noopMiddleware(uo, args);
        },
        paymasterAndData: async (uo, { account, client, feeOptions, overrides: overrides_ }) => {
            if (!client.chain) {
                throw new ChainNotFoundError();
            }
            const userOp = deepHexlify(await resolveProperties(uo));
            const overrides = filterUndefined({
                maxFeePerGas: overrideField("maxFeePerGas", overrides_, feeOptions, userOp),
                maxPriorityFeePerGas: overrideField("maxPriorityFeePerGas", overrides_, feeOptions, userOp),
                callGasLimit: overrideField("callGasLimit", overrides_, feeOptions, userOp),
                verificationGasLimit: overrideField("verificationGasLimit", overrides_, feeOptions, userOp),
                preVerificationGas: overrideField("preVerificationGas", overrides_, feeOptions, userOp),
                ...(account.getEntryPoint().version === "0.7.0"
                    ? {
                        paymasterVerificationGasLimit: overrideField("paymasterVerificationGasLimit", overrides_, feeOptions, userOp),
                        paymasterPostOpGasLimit: overrideField("paymasterPostOpGasLimit", overrides_, feeOptions, userOp),
                    }
                    : {}),
            });
            const result = await client.request({
                method: "alchemy_requestGasAndPaymasterAndData",
                params: [
                    {
                        policyId,
                        entryPoint: account.getEntryPoint().address,
                        userOperation: userOp,
                        dummySignature: await account.getDummySignature(),
                        overrides,
                    },
                ],
            });
            return {
                ...uo,
                ...result,
            };
        },
    };
}
/**
 * Utility function to override a field in the user operation request with the overrides or fee options
 *
 * @template {EntryPointVersion} TEntryPointVersion
 * @param {keyof UserOperationFeeOptions<TEntryPointVersion>} field the field to override
 * @param {UserOperationOverrides<TEntryPointVersion> | undefined} overrides the overrides object
 * @param {UserOperationFeeOptions<TEntryPointVersion> | undefined} feeOptions the fee options object from the client
 * @param {UserOperationRequest<TEntryPointVersion>} userOperation the user operation request
 * @returns {Hex | Multiplier | undefined} the overridden field value
 */
const overrideField = (field, overrides, feeOptions, userOperation) => {
    let _field = field;
    if (overrides?.[_field] != null) {
        // one-off absolute override
        if (isBigNumberish(overrides[_field])) {
            return deepHexlify(overrides[_field]);
        }
        // one-off multiplier overrides
        else {
            return {
                multiplier: Number(overrides[_field].multiplier),
            };
        }
    }
    // provider level fee options with multiplier
    if (isMultiplier(feeOptions?.[field])) {
        return {
            multiplier: Number(feeOptions[field].multiplier),
        };
    }
    const userOpField = userOperation[field];
    if (isHex(userOpField) && fromHex(userOpField, "bigint") > 0n) {
        return userOpField;
    }
    return undefined;
};
//# sourceMappingURL=gasManager.js.map