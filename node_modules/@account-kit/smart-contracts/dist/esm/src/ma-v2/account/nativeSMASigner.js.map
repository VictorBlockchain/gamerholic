{"version":3,"file":"nativeSMASigner.js","sourceRoot":"","sources":["../../../../../src/ma-v2/account/nativeSMASigner.ts"],"names":[],"mappings":"AACA,OAAO,EACL,WAAW,EACX,aAAa,GAOd,MAAM,MAAM,CAAC;AAEd,OAAO,EACL,eAAe,EACf,iBAAiB,EACjB,uBAAuB,GACxB,MAAM,aAAa,CAAC;AACrB;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,CAC7B,MAA0B,EAC1B,KAAY,EACZ,cAAuB,EACvB,EAAE;IACF,OAAO;QACL,iBAAiB,EAAE,GAAQ,EAAE;YAC3B,MAAM,mBAAmB,GACvB,sIAAsI,CAAC;YAEzI,OAAO,eAAe,CAAC;gBACrB,uBAAuB;gBACvB,mBAAmB,EAAE,mBAAmB;aACzC,CAAC,CAAC;QACL,CAAC;QAED,qBAAqB,EAAE,CAAC,MAAW,EAAgB,EAAE;YACnD,OAAO,MAAM,CAAC,WAAW,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,SAAc,EAAE,EAAE,CACjE,eAAe,CAAC;gBACd,uBAAuB;gBACvB,mBAAmB,EAAE,SAAS;aAC/B,CAAC,CACH,CAAC;QACJ,CAAC;QAED,oFAAoF;QACpF,KAAK,CAAC,WAAW,CAAC,EAAE,OAAO,EAAgC;YACzD,MAAM,IAAI,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC;YAElC,OAAO,iBAAiB,CAAC;gBACvB,mBAAmB,EAAE,MAAM,MAAM,CAAC,aAAa,CAAC;oBAC9C,MAAM,EAAE;wBACN,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;wBACzB,iBAAiB,EAAE,cAAc;qBAClC;oBACD,KAAK,EAAE;wBACL,cAAc,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC;qBACpD;oBACD,OAAO,EAAE;wBACP,IAAI;qBACL;oBACD,WAAW,EAAE,gBAAgB;iBAC9B,CAAC;gBACF,QAAQ,EAAE,uBAAuB;aAClC,CAAC,CAAC;QACL,CAAC;QAED,mEAAmE;QACnE,qHAAqH;QACrH,aAAa,EAAE,KAAK,EAIlB,mBAAgE,EAClD,EAAE;YAChB,uIAAuI;YACvI,MAAM,gBAAgB,GACpB,mBAAmB,EAAE,WAAW,KAAK,gBAAgB;gBACrD,mBAAmB,EAAE,MAAM,EAAE,iBAAiB,KAAK,cAAc,CAAC;YAEpE,OAAO,gBAAgB;gBACrB,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,mBAAmB,CAAC;gBAC3C,CAAC,CAAC,iBAAiB,CAAC;oBAChB,mBAAmB,EAAE,MAAM,MAAM,CAAC,aAAa,CAAC;wBAC9C,MAAM,EAAE;4BACN,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;4BACzB,iBAAiB,EAAE,cAAc;yBAClC;wBACD,KAAK,EAAE;4BACL,cAAc,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC;yBACpD;wBACD,OAAO,EAAE;4BACP,IAAI,EAAE,MAAM,aAAa,CAAC,mBAAmB,CAAC;yBAC/C;wBACD,WAAW,EAAE,gBAAgB;qBAC9B,CAAC;oBACF,QAAQ,EAAE,uBAAuB;iBAClC,CAAC,CAAC;QACT,CAAC;KACF,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import type { SmartAccountSigner } from \"@aa-sdk/core\";\nimport {\n  hashMessage,\n  hashTypedData,\n  type Hex,\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type Chain,\n  type Address,\n} from \"viem\";\n\nimport {\n  packUOSignature,\n  pack1271Signature,\n  DEFAULT_OWNER_ENTITY_ID,\n} from \"../utils.js\";\n/**\n * Creates an object with methods for generating a dummy signature, signing user operation hashes, signing messages, and signing typed data.\n *\n * @example\n * ```ts\n * import { nativeSMASigner } from \"@account-kit/smart-contracts\";\n \n * import { LocalAccountSigner } from \"@aa-sdk/core\";\n *\n * const MNEMONIC = \"...\":\n *\n * const account = createModularAccountV2({ config });\n *\n * const signer = LocalAccountSigner.mnemonicToAccountSigner(MNEMONIC);\n *\n * const messageSigner = nativeSMASigner(signer, chain, account.address);\n * ```\n *\n * @param {SmartAccountSigner} signer Signer to use for signing operations\n * @param {Chain} chain Chain object for the signer\n * @param {Address} accountAddress address of the smart account using this signer\n * @returns {object} an object with methods for signing operations and managing signatures\n */\nexport const nativeSMASigner = (\n  signer: SmartAccountSigner,\n  chain: Chain,\n  accountAddress: Address\n) => {\n  return {\n    getDummySignature: (): Hex => {\n      const dummyEcdsaSignature =\n        \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\n      return packUOSignature({\n        // orderedHookData: [],\n        validationSignature: dummyEcdsaSignature,\n      });\n    },\n\n    signUserOperationHash: (uoHash: Hex): Promise<Hex> => {\n      return signer.signMessage({ raw: uoHash }).then((signature: Hex) =>\n        packUOSignature({\n          // orderedHookData: [],\n          validationSignature: signature,\n        })\n      );\n    },\n\n    // we apply the expected 1271 packing here since the account contract will expect it\n    async signMessage({ message }: { message: SignableMessage }): Promise<Hex> {\n      const hash = hashMessage(message);\n\n      return pack1271Signature({\n        validationSignature: await signer.signTypedData({\n          domain: {\n            chainId: Number(chain.id),\n            verifyingContract: accountAddress,\n          },\n          types: {\n            ReplaySafeHash: [{ name: \"hash\", type: \"bytes32\" }],\n          },\n          message: {\n            hash,\n          },\n          primaryType: \"ReplaySafeHash\",\n        }),\n        entityId: DEFAULT_OWNER_ENTITY_ID,\n      });\n    },\n\n    // TODO: maybe move \"sign deferred actions\" to a separate function?\n    // we don't apply the expected 1271 packing since deferred sigs use typed data sigs and don't expect the 1271 packing\n    signTypedData: async <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData\n    >(\n      typedDataDefinition: TypedDataDefinition<typedData, primaryType>\n    ): Promise<Hex> => {\n      // the accounts domain already gives replay protection across accounts for deferred actions, so we don't need to apply another wrapping\n      const isDeferredAction =\n        typedDataDefinition?.primaryType === \"DeferredAction\" &&\n        typedDataDefinition?.domain?.verifyingContract === accountAddress;\n\n      return isDeferredAction\n        ? signer.signTypedData(typedDataDefinition)\n        : pack1271Signature({\n            validationSignature: await signer.signTypedData({\n              domain: {\n                chainId: Number(chain.id),\n                verifyingContract: accountAddress,\n              },\n              types: {\n                ReplaySafeHash: [{ name: \"hash\", type: \"bytes32\" }],\n              },\n              message: {\n                hash: await hashTypedData(typedDataDefinition),\n              },\n              primaryType: \"ReplaySafeHash\",\n            }),\n            entityId: DEFAULT_OWNER_ENTITY_ID,\n          });\n    },\n  };\n};\n"]}