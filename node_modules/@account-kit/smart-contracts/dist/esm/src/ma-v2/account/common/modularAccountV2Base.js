import { createBundlerClient, getEntryPoint, InvalidEntityIdError, InvalidNonceKeyError, toSmartContractAccount, } from "@aa-sdk/core";
import { DEFAULT_OWNER_ENTITY_ID } from "../../utils.js";
import { encodeFunctionData, maxUint32, zeroAddress, getContract, concatHex, maxUint152, } from "viem";
import { modularAccountAbi } from "../../abis/modularAccountAbi.js";
import { serializeModuleEntity } from "../../actions/common/utils.js";
import { nativeSMASigner } from "../nativeSMASigner.js";
import { singleSignerMessageSigner } from "../../modules/single-signer-validation/signer.js";
export const executeUserOpSelector = "0x8DD7712F";
export async function createMAv2Base(config) {
    const { transport, chain, signer, entryPoint = getEntryPoint(chain, { version: "0.7.0" }), signerEntity = {
        isGlobalValidation: true,
        entityId: DEFAULT_OWNER_ENTITY_ID,
    }, signerEntity: { isGlobalValidation = true, entityId = DEFAULT_OWNER_ENTITY_ID, } = {}, accountAddress, ...remainingToSmartContractAccountParams } = config;
    if (entityId > Number(maxUint32)) {
        throw new InvalidEntityIdError(entityId);
    }
    const client = createBundlerClient({
        transport,
        chain,
    });
    const encodeExecute = async ({ target, data, value, }) => await encodeCallData(encodeFunctionData({
        abi: modularAccountAbi,
        functionName: "execute",
        args: [target, value ?? 0n, data],
    }));
    const encodeBatchExecute = async (txs) => await encodeCallData(encodeFunctionData({
        abi: modularAccountAbi,
        functionName: "executeBatch",
        args: [
            txs.map((tx) => ({
                target: tx.target,
                data: tx.data,
                value: tx.value ?? 0n,
            })),
        ],
    }));
    const isAccountDeployed = async () => !!(await client.getCode({ address: accountAddress }));
    // TODO: add deferred action flag
    const getNonce = async (nonceKey = 0n) => {
        if (nonceKey > maxUint152) {
            throw new InvalidNonceKeyError(nonceKey);
        }
        const entryPointContract = getContract({
            address: entryPoint.address,
            abi: entryPoint.abi,
            client,
        });
        const fullNonceKey = (nonceKey << 40n) +
            (BigInt(entityId) << 8n) +
            (isGlobalValidation ? 1n : 0n);
        return entryPointContract.read.getNonce([
            accountAddress,
            fullNonceKey,
        ]);
    };
    const accountContract = getContract({
        address: accountAddress,
        abi: modularAccountAbi,
        client,
    });
    const getExecutionData = async (selector) => {
        if (!(await isAccountDeployed())) {
            return {
                module: zeroAddress,
                skipRuntimeValidation: false,
                allowGlobalValidation: false,
                executionHooks: [],
            };
        }
        return await accountContract.read.getExecutionData([selector]);
    };
    const getValidationData = async (args) => {
        if (!(await isAccountDeployed())) {
            return {
                validationHooks: [],
                executionHooks: [],
                selectors: [],
                validationFlags: 0,
            };
        }
        const { validationModuleAddress, entityId } = args;
        return await accountContract.read.getValidationData([
            serializeModuleEntity({
                moduleAddress: validationModuleAddress ?? zeroAddress,
                entityId: entityId ?? Number(maxUint32),
            }),
        ]);
    };
    const encodeCallData = async (callData) => {
        const validationData = await getValidationData({
            entityId: Number(entityId),
        });
        return validationData.executionHooks.length
            ? concatHex([executeUserOpSelector, callData])
            : callData;
    };
    const baseAccount = await toSmartContractAccount({
        ...remainingToSmartContractAccountParams,
        transport,
        chain,
        entryPoint,
        accountAddress,
        encodeExecute,
        encodeBatchExecute,
        getNonce,
        ...(entityId === DEFAULT_OWNER_ENTITY_ID
            ? nativeSMASigner(signer, chain, accountAddress)
            : singleSignerMessageSigner(signer, chain, accountAddress, entityId)),
    });
    return {
        ...baseAccount,
        getSigner: () => signer,
        signerEntity,
        getExecutionData,
        getValidationData,
        encodeCallData,
    };
}
//# sourceMappingURL=modularAccountV2Base.js.map