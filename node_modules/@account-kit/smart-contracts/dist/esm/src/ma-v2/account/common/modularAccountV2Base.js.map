{"version":3,"file":"modularAccountV2Base.js","sourceRoot":"","sources":["../../../../../../src/ma-v2/account/common/modularAccountV2Base.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  createBundlerClient,\n  getEntryPoint,\n  InvalidEntityIdError,\n  InvalidNonceKeyError,\n  toSmartContractAccount,\n  type AccountOp,\n  type SmartAccountSigner,\n  type SmartContractAccountWithSigner,\n  type ToSmartContractAccountParams,\n} from \"@aa-sdk/core\";\nimport { DEFAULT_OWNER_ENTITY_ID } from \"../../utils.js\";\nimport {\n  type Hex,\n  type Address,\n  type Chain,\n  type Transport,\n  encodeFunctionData,\n  maxUint32,\n  zeroAddress,\n  getContract,\n  concatHex,\n  maxUint152,\n} from \"viem\";\nimport { modularAccountAbi } from \"../../abis/modularAccountAbi.js\";\nimport { serializeModuleEntity } from \"../../actions/common/utils.js\";\nimport { nativeSMASigner } from \"../nativeSMASigner.js\";\nimport { singleSignerMessageSigner } from \"../../modules/single-signer-validation/signer.js\";\n\nexport const executeUserOpSelector: Hex = \"0x8DD7712F\";\n\nexport type SignerEntity = {\n  isGlobalValidation: boolean;\n  entityId: number;\n};\n\nexport type ExecutionDataView = {\n  module: Address;\n  skipRuntimeValidation: boolean;\n  allowGlobalValidation: boolean;\n  executionHooks: readonly Hex[];\n};\n\nexport type ValidationDataView = {\n  validationHooks: readonly Hex[];\n  executionHooks: readonly Hex[];\n  selectors: readonly Hex[];\n  validationFlags: number;\n};\n\nexport type ValidationDataParams =\n  | {\n      validationModuleAddress: Address;\n      entityId?: never;\n    }\n  | {\n      validationModuleAddress?: never;\n      entityId: number;\n    };\n\nexport type ModularAccountV2<\n  TSigner extends SmartAccountSigner = SmartAccountSigner\n> = SmartContractAccountWithSigner<\"ModularAccountV2\", TSigner, \"0.7.0\"> & {\n  signerEntity: SignerEntity;\n  getExecutionData: (selector: Hex) => Promise<ExecutionDataView>;\n  getValidationData: (\n    args: ValidationDataParams\n  ) => Promise<ValidationDataView>;\n  encodeCallData: (callData: Hex) => Promise<Hex>;\n};\n\nexport type CreateMAV2BaseParams<\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n  TTransport extends Transport = Transport\n> = Omit<\n  ToSmartContractAccountParams<\"ModularAccountV2\", TTransport, Chain, \"0.7.0\">,\n  // Implements the following methods required by `toSmartContractAccount`, and passes through any other parameters.\n  | \"encodeExecute\"\n  | \"encodeBatchExecute\"\n  | \"getNonce\"\n  | \"signMessage\"\n  | \"signTypedData\"\n  | \"getDummySignature\"\n> & {\n  signer: TSigner;\n  signerEntity?: SignerEntity;\n  accountAddress: Address;\n};\n\nexport type CreateMAV2BaseReturnType<\n  TSigner extends SmartAccountSigner = SmartAccountSigner\n> = Promise<ModularAccountV2<TSigner>>;\n\nexport async function createMAv2Base<\n  TSigner extends SmartAccountSigner = SmartAccountSigner\n>(config: CreateMAV2BaseParams<TSigner>): CreateMAV2BaseReturnType<TSigner> {\n  const {\n    transport,\n    chain,\n    signer,\n    entryPoint = getEntryPoint(chain, { version: \"0.7.0\" }),\n    signerEntity = {\n      isGlobalValidation: true,\n      entityId: DEFAULT_OWNER_ENTITY_ID,\n    },\n    signerEntity: {\n      isGlobalValidation = true,\n      entityId = DEFAULT_OWNER_ENTITY_ID,\n    } = {},\n    accountAddress,\n    ...remainingToSmartContractAccountParams\n  } = config;\n\n  if (entityId > Number(maxUint32)) {\n    throw new InvalidEntityIdError(entityId);\n  }\n\n  const client = createBundlerClient({\n    transport,\n    chain,\n  });\n\n  const encodeExecute: (tx: AccountOp) => Promise<Hex> = async ({\n    target,\n    data,\n    value,\n  }) =>\n    await encodeCallData(\n      encodeFunctionData({\n        abi: modularAccountAbi,\n        functionName: \"execute\",\n        args: [target, value ?? 0n, data],\n      })\n    );\n\n  const encodeBatchExecute: (txs: AccountOp[]) => Promise<Hex> = async (txs) =>\n    await encodeCallData(\n      encodeFunctionData({\n        abi: modularAccountAbi,\n        functionName: \"executeBatch\",\n        args: [\n          txs.map((tx) => ({\n            target: tx.target,\n            data: tx.data,\n            value: tx.value ?? 0n,\n          })),\n        ],\n      })\n    );\n\n  const isAccountDeployed: () => Promise<boolean> = async () =>\n    !!(await client.getCode({ address: accountAddress }));\n  // TODO: add deferred action flag\n  const getNonce = async (nonceKey: bigint = 0n): Promise<bigint> => {\n    if (nonceKey > maxUint152) {\n      throw new InvalidNonceKeyError(nonceKey);\n    }\n\n    const entryPointContract = getContract({\n      address: entryPoint.address,\n      abi: entryPoint.abi,\n      client,\n    });\n\n    const fullNonceKey: bigint =\n      (nonceKey << 40n) +\n      (BigInt(entityId) << 8n) +\n      (isGlobalValidation ? 1n : 0n);\n\n    return entryPointContract.read.getNonce([\n      accountAddress,\n      fullNonceKey,\n    ]) as Promise<bigint>;\n  };\n\n  const accountContract = getContract({\n    address: accountAddress,\n    abi: modularAccountAbi,\n    client,\n  });\n\n  const getExecutionData = async (selector: Hex) => {\n    if (!(await isAccountDeployed())) {\n      return {\n        module: zeroAddress,\n        skipRuntimeValidation: false,\n        allowGlobalValidation: false,\n        executionHooks: [],\n      };\n    }\n\n    return await accountContract.read.getExecutionData([selector]);\n  };\n\n  const getValidationData = async (args: ValidationDataParams) => {\n    if (!(await isAccountDeployed())) {\n      return {\n        validationHooks: [],\n        executionHooks: [],\n        selectors: [],\n        validationFlags: 0,\n      };\n    }\n\n    const { validationModuleAddress, entityId } = args;\n    return await accountContract.read.getValidationData([\n      serializeModuleEntity({\n        moduleAddress: validationModuleAddress ?? zeroAddress,\n        entityId: entityId ?? Number(maxUint32),\n      }),\n    ]);\n  };\n\n  const encodeCallData = async (callData: Hex): Promise<Hex> => {\n    const validationData = await getValidationData({\n      entityId: Number(entityId),\n    });\n\n    return validationData.executionHooks.length\n      ? concatHex([executeUserOpSelector, callData])\n      : callData;\n  };\n\n  const baseAccount = await toSmartContractAccount({\n    ...remainingToSmartContractAccountParams,\n    transport,\n    chain,\n    entryPoint,\n    accountAddress,\n    encodeExecute,\n    encodeBatchExecute,\n    getNonce,\n    ...(entityId === DEFAULT_OWNER_ENTITY_ID\n      ? nativeSMASigner(signer, chain, accountAddress)\n      : singleSignerMessageSigner(signer, chain, accountAddress, entityId)),\n  });\n\n  return {\n    ...baseAccount,\n    getSigner: () => signer,\n    signerEntity,\n    getExecutionData,\n    getValidationData,\n    encodeCallData,\n  };\n}\n"]}