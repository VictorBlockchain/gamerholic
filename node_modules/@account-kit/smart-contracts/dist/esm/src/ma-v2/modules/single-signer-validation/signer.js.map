{"version":3,"file":"signer.js","sourceRoot":"","sources":["../../../../../../src/ma-v2/modules/single-signer-validation/signer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SmartAccountSigner } from \"@aa-sdk/core\";\nimport {\n  hashMessage,\n  hashTypedData,\n  concatHex,\n  type Hex,\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type Chain,\n  type Address,\n} from \"viem\";\nimport { getDefaultSingleSignerValidationModuleAddress } from \"../utils.js\";\n\nimport { packUOSignature, pack1271Signature } from \"../../utils.js\";\n/**\n * Creates an object with methods for generating a dummy signature, signing user operation hashes, signing messages, and signing typed data.\n *\n * @example \n \n * ```ts\n * import { singleSignerMessageSigner } from \"@account-kit/smart-contracts\";\n * import { LocalAccountSigner } from \"@aa-sdk/core\";\n *\n * const MNEMONIC = \"...\":\n * \n * const account = createModularAccountV2({ config });\n *\n * const signer = LocalAccountSigner.mnemonicToAccountSigner(MNEMONIC);\n *\n * const messageSigner = singleSignerMessageSigner(signer, chain, account.address, account.signerEntity.entityId);\n * ```\n *\n * @param {SmartAccountSigner} signer Signer to use for signing operations\n * @param {Chain} chain Chain object for the signer\n * @param {Address} accountAddress address of the smart account using this signer\n * @param {number} entityId the entity id of the signing validation\n * @returns {object} an object with methods for signing operations and managing signatures\n */\nexport const singleSignerMessageSigner = (\n  signer: SmartAccountSigner,\n  chain: Chain,\n  accountAddress: Address,\n  entityId: number\n) => {\n  return {\n    getDummySignature: (): Hex => {\n      const dummyEcdsaSignature =\n        \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\n      return packUOSignature({\n        // orderedHookData: [],\n        validationSignature: dummyEcdsaSignature,\n      });\n    },\n\n    signUserOperationHash: (uoHash: Hex): Promise<Hex> => {\n      return signer.signMessage({ raw: uoHash }).then((signature: Hex) =>\n        packUOSignature({\n          // orderedHookData: [],\n          validationSignature: signature,\n        })\n      );\n    },\n\n    // we apply the expected 1271 packing here since the account contract will expect it\n    async signMessage({ message }: { message: SignableMessage }): Promise<Hex> {\n      const hash = await hashMessage(message);\n\n      return pack1271Signature({\n        validationSignature: await signer.signTypedData({\n          domain: {\n            chainId: Number(chain.id),\n            verifyingContract:\n              getDefaultSingleSignerValidationModuleAddress(chain),\n            salt: concatHex([`0x${\"00\".repeat(12)}`, accountAddress]),\n          },\n          types: {\n            ReplaySafeHash: [{ name: \"hash\", type: \"bytes32\" }],\n          },\n          message: {\n            hash,\n          },\n          primaryType: \"ReplaySafeHash\",\n        }),\n        entityId,\n      });\n    },\n\n    // TODO: maybe move \"sign deferred actions\" to a separate function?\n    // we don't apply the expected 1271 packing since deferred sigs use typed data sigs and don't expect the 1271 packing\n    signTypedData: async <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData\n    >(\n      typedDataDefinition: TypedDataDefinition<typedData, primaryType>\n    ): Promise<Hex> => {\n      // the accounts domain already gives replay protection across accounts for deferred actions, so we don't need to apply another wrapping\n      const isDeferredAction =\n        typedDataDefinition?.primaryType === \"DeferredAction\" &&\n        typedDataDefinition?.domain?.verifyingContract === accountAddress;\n\n      const validationSignature = await signer.signTypedData({\n        domain: {\n          chainId: Number(chain.id),\n          verifyingContract:\n            getDefaultSingleSignerValidationModuleAddress(chain),\n          salt: concatHex([`0x${\"00\".repeat(12)}`, accountAddress]),\n        },\n        types: {\n          ReplaySafeHash: [{ name: \"hash\", type: \"bytes32\" }],\n        },\n        message: {\n          hash: await hashTypedData(typedDataDefinition),\n        },\n        primaryType: \"ReplaySafeHash\",\n      });\n\n      return isDeferredAction\n        ? validationSignature\n        : pack1271Signature({\n            validationSignature,\n            entityId,\n          });\n    },\n  };\n};\n"]}