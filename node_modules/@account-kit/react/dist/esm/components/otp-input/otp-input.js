import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React, { useEffect, useRef, useState } from "react";
import { ls } from "../../strings.js";
export const initialOTPValue = ["", "", "", "", "", ""];
const OTP_LENGTH = 6;
export const isOTPCodeType = (arg) => {
    return (Array.isArray(arg) &&
        arg.every((item) => typeof item === "string" && item !== "") &&
        arg.length === OTP_LENGTH);
};
export const OTPInput = ({ value, setValue, errorText, disabled, setErrorText, handleReset, className, isVerified, }) => {
    const [autoComplete, setAutoComplete] = useState("");
    const [activeElement, setActiveElement] = useState(0);
    const refs = useRef([]);
    // Initialize refs
    useEffect(() => {
        refs.current = refs.current.slice(0, OTP_LENGTH);
        refs.current[0]?.focus();
    }, []);
    // Select active element when active element value changes
    useEffect(() => {
        if (activeElement !== null && refs.current[activeElement]) {
            refs.current[activeElement]?.select();
            refs.current[activeElement]?.focus();
        }
    }, [activeElement]);
    useEffect(() => {
        const newValue = autoComplete.split("");
        if (isOTPCodeType(newValue)) {
            setValue(newValue);
        }
    }, [autoComplete, setValue]);
    const handleChange = (e, i) => {
        //Fix for ios chrome autocomplete
        if (e.target.value.length === OTP_LENGTH) {
            const chromeIOSAutocomplete = e.target.value.split("");
            if (isOTPCodeType(chromeIOSAutocomplete)) {
                setValue(chromeIOSAutocomplete);
                setActiveElement(null);
                return;
            }
        }
        const newValue = [...value];
        newValue.splice(i, 1, e.target.value);
        setErrorText("");
        setValue(newValue);
        focusNextElement();
    };
    const handleClick = (i) => {
        refs.current[i]?.select();
        setActiveElement(i);
        setErrorText("");
    };
    const focusNextElement = () => {
        const nextElement = activeElement ? activeElement + 1 : 1;
        setActiveElement(nextElement);
    };
    const focusPreviousElement = () => {
        const previousElement = activeElement ? activeElement - 1 : 0;
        setActiveElement(previousElement);
    };
    const handlePaste = (e) => {
        e.preventDefault();
        const pasteData = e.clipboardData
            .getData("text/plain")
            .split("")
            .slice(0, OTP_LENGTH);
        if (isOTPCodeType(pasteData)) {
            setValue(pasteData);
        }
        else {
            setErrorText(ls.error.otp.invalid);
        }
    };
    const handleKeydown = (e) => {
        if (activeElement === null)
            return;
        switch (e.key) {
            case "Backspace":
                e.preventDefault();
                const newValue = [...value];
                newValue.splice(activeElement, 1, "");
                setValue(newValue);
                focusPreviousElement();
                break;
            case "ArrowLeft":
                e.preventDefault();
                focusPreviousElement();
                break;
            case "ArrowRight":
                e.preventDefault();
                if (activeElement < OTP_LENGTH - 1)
                    focusNextElement();
                break;
            case "Spacebar": {
                break;
            }
        }
    };
    return (_jsxs("div", { className: `flex flex-col gap-2 items-center ${className}`, children: [_jsx("input", { className: "invisible h-0 w-0 p-[0] m-[-1px]", tabIndex: -1, "aria-hidden": true, autoComplete: "one-time-code", value: autoComplete, onChange: (e) => setAutoComplete(e.target.value), onClick: handleReset }), _jsx("div", { className: "flex gap-2.5", children: initialOTPValue.map((_, i) => (_jsx("input", { className: `
              border w-8 h-10 rounded text-center 
              focus:outline-none focus:border-active 
              ${!disabled ? "bg-bg-surface-default text-fg-primary" : ""}
              ${!!errorText ? "border-fg-critical" : ""} 
              ${isVerified ? "border-fg-success" : ""}
              ${disabled
                        ? "border-fg-disabled bg-bg-surface-inset text-fg-disabled"
                        : ""}
            `, ref: (el) => (refs.current[i] = el), tabIndex: i + 1, type: "text", "aria-label": `One time password input for the ${i + 1} digit`, inputMode: "numeric", pattern: "[0-9]*", 
                    //Fix for ios chrome autocomplete
                    maxLength: i === 0 ? OTP_LENGTH : 1, onFocus: () => setActiveElement(i), onPaste: handlePaste, onChange: (e) => handleChange(e, i), onClick: () => handleClick(i), onInput: focusNextElement, onKeyDown: handleKeydown, disabled: disabled || isVerified, value: value[i], "aria-invalid": !!errorText }, i))) }), errorText && (_jsx("p", { className: "text-fg-critical text-sm text-center", children: errorText }))] }));
};
//# sourceMappingURL=otp-input.js.map