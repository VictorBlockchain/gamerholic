import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useForm } from "@tanstack/react-form";
import { zodValidator } from "@tanstack/zod-form-adapter";
import { memo } from "react";
import { z } from "zod";
import { useAuthenticate } from "../../../hooks/useAuthenticate.js";
import { useSigner } from "../../../hooks/useSigner.js";
import { ChevronRight } from "../../../icons/chevron.js";
import { MailIcon } from "../../../icons/mail.js";
import { ls } from "../../../strings.js";
import { Button } from "../../button.js";
import { IS_SIGNUP_QP } from "../../constants.js";
import { Input } from "../../input.js";
import { useAuthContext } from "../context.js";
// this is not used externally
// eslint-disable-next-line jsdoc/require-jsdoc
export const EmailAuth = memo(({ emailMode = "otp", hideButton = false, buttonLabel = ls.login.email.button, placeholder = ls.login.email.placeholder, }) => {
    const { setAuthStep } = useAuthContext();
    const signer = useSigner();
    const { authenticateAsync, isPending } = useAuthenticate({
        onMutate: async (params) => {
            if (params.type === "email" && "email" in params) {
                if (params.emailMode === "magicLink") {
                    setAuthStep({ type: "email_verify", email: params.email });
                }
                else {
                    setAuthStep({ type: "otp_verify", email: params.email });
                }
            }
        },
        onSuccess: () => {
            setAuthStep({ type: "complete" });
        },
        onError: (error) => {
            console.error(error);
            setAuthStep({ type: "initial", error });
        },
    });
    const form = useForm({
        defaultValues: {
            email: "",
        },
        onSubmit: async ({ value: { email } }) => {
            try {
                const existingUser = await signer?.getUser(email);
                const redirectParams = new URLSearchParams();
                if (existingUser == null) {
                    redirectParams.set(IS_SIGNUP_QP, "true");
                }
                await authenticateAsync({
                    type: "email",
                    email,
                    emailMode,
                    redirectParams,
                });
            }
            catch (e) {
                const error = e instanceof Error ? e : new Error("An Unknown error");
                setAuthStep({ type: "initial", error });
            }
        },
        validatorAdapter: zodValidator(),
    });
    return (_jsx("form", { className: "w-full", onSubmit: (e) => {
            e.stopPropagation();
            e.preventDefault();
            form.handleSubmit();
        }, children: _jsxs("div", { className: "flex flex-col gap-2 w-full", children: [_jsx(form.Field, { name: "email", validators: {
                        onChange: z.string().email("Must provide a valid email."),
                    }, children: (field) => (_jsx(Input, { name: field.name, value: field.state.value, onChange: (e) => field.handleChange(e.target.value), onBlur: field.handleBlur, placeholder: placeholder, type: "email", iconLeft: _jsx(MailIcon, {}), iconRight: hideButton ? (_jsx("button", { type: "submit", className: "match-input cursor-pointer focus:outline-none focus:opacity-25", children: _jsx(ChevronRight, {}) })) : undefined, disabled: isPending })) }), _jsx(form.Subscribe, { selector: (state) => [
                        state.canSubmit,
                        state.isSubmitting,
                        state.values.email,
                    ], children: ([canSubmit, isSubmitting, email]) => !hideButton ? (_jsx(Button, { type: "submit", variant: "primary", disabled: Boolean(isPending || !canSubmit || isSubmitting || !email), children: buttonLabel })) : null })] }) }));
});
//# sourceMappingURL=EmailAuth.js.map