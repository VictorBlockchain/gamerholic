import { type SmartAccountAuthenticator } from "@aa-sdk/core";
import { type GetTransactionType, type Hex, type IsNarrowable, type LocalAccount, type SerializeTransactionFn, type SignableMessage, type TransactionSerializable, type TransactionSerialized, type TypedData, type TypedDataDefinition } from "viem";
import { type Authorization } from "viem/experimental";
import type { BaseSignerClient } from "./client/base";
import type { OauthConfig, User } from "./client/types";
import { type SessionManagerParams } from "./session/manager.js";
import type { AuthParams } from "./signer";
import { SolanaSigner } from "./solanaSigner.js";
import { type AlchemySignerEvents, type ErrorInfo } from "./types.js";
export interface BaseAlchemySignerParams<TClient extends BaseSignerClient> {
    client: TClient;
    sessionConfig?: Omit<SessionManagerParams, "client">;
    initialError?: ErrorInfo;
}
/**
 * Base abstract class for Alchemy Signer, providing authentication and session management for smart accounts.
 * Implements the `SmartAccountAuthenticator` interface and handles various signer events.
 */
export declare abstract class BaseAlchemySigner<TClient extends BaseSignerClient> implements SmartAccountAuthenticator<AuthParams, User, TClient> {
    signerType: "alchemy-signer" | "rn-alchemy-signer";
    inner: TClient;
    private sessionManager;
    private store;
    /**
     * Initializes an instance with the provided client and session configuration.
     * This function sets up the internal store, initializes the session manager,
     * registers listeners and initializes the session manager to manage session state.
     *
     * @param {BaseAlchemySignerParams<TClient>} param0 Object containing the client and session configuration
     * @param {TClient} param0.client The client instance to be used internally
     * @param {SessionConfig} param0.sessionConfig Configuration for managing sessions
     * @param {ErrorInfo | undefined} param0.initialError Error already present on the signer when initialized, if any
     */
    constructor({ client, sessionConfig, initialError, }: BaseAlchemySignerParams<TClient>);
    /**
     * Allows you to subscribe to events emitted by the signer
     *
     * @param {AlchemySignerEvent} event the event to subscribe to
     * @param {AlchemySignerEvents[AlchemySignerEvent]} listener the function to run when the event is emitted
     * @returns {() => void} a function to remove the listener
     */
    on: <E extends keyof AlchemySignerEvents>(event: E, listener: AlchemySignerEvents[E]) => () => void;
    /**
     * Prepares the config needed to use popup-based OAuth login. This must be
     * called before calling `.authenticate` with params `{ type: "oauth", mode:
     * "popup" }`, and is recommended to be called on page load.
     *
     * This method exists because browsers may prevent popups from opening unless
     * triggered by user interaction, and so the OAuth config must already have
     * been fetched at the time a user clicks a social login button.
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * await signer.preparePopupOauth();
     * ```
     * @returns {Promise<OauthConfig>} the config which must be loaded before
     * using popup-based OAuth
     */
    preparePopupOauth: () => Promise<OauthConfig>;
    /**
     * Authenticate a user with either an email or a passkey and create a session for that user
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const result = await signer.authenticate({
     *  type: "email",
     *  email: "foo@mail.com",
     * });
     * ```
     *
     * @param {AuthParams} params - undefined if passkey login, otherwise an object with email and bundle to resolve
     * @returns {Promise<User>} the user that was authenticated
     */
    authenticate: (params: AuthParams) => Promise<User>;
    private trackAuthenticateType;
    /**
     * Clear a user session and log them out
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * await signer.disconnect();
     * ```
     *
     * @returns {Promise<void>} a promise that resolves when the user is logged out
     */
    disconnect: () => Promise<void>;
    /**
     * Gets the current logged in user
     * If a user has an ongoing session, it will use that session and
     * try to authenticate
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * // throws if not logged in
     * const user = await signer.getAuthDetails();
     * ```
     *
     * @throws if there is no user logged in
     * @returns {Promise<User>} the current user
     */
    getAuthDetails: () => Promise<User>;
    /**
     * Retrieves the address of the current user by calling the `whoami` method on `this.inner`.
     *
     * @returns {Promise<string>} A promise that resolves to the address of the current user.
     */
    getAddress: () => Promise<`0x${string}`>;
    /**
     * Signs a raw message after hashing it.
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const signature = await signer.signMessage("Hello, world!");
     * ```
     *
     * @param {string} msg the message to be hashed and then signed
     * @returns {Promise<string>} a promise that resolves to the signed message
     */
    signMessage: (msg: SignableMessage) => Promise<`0x${string}`>;
    /**
     * Signs a typed message by first hashing it and then signing the hashed message using the `signRawMessage` method.
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const signature = await signer.signTypedData({
     *  domain: {},
     *  types: {},
     *  primaryType: "",
     *  message: {},
     * });
     * ```
     *
     * @param {TypedDataDefinition<TTypedData, TPrimaryType>} params The parameters for the typed message to be hashed and signed
     * @returns {Promise<any>} A promise that resolves to the signed message
     */
    signTypedData: <const TTypedData extends TypedData | Record<string, unknown>, TPrimaryType extends keyof TTypedData | "EIP712Domain" = keyof TTypedData>(params: TypedDataDefinition<TTypedData, TPrimaryType>) => Promise<Hex>;
    /**
     * Serializes a transaction, signs it with a raw message, and then returns the serialized transaction with the signature.
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const tx = await signer.signTransaction({
     *  to: "0x1234",
     *  value: "0x1234",
     *  data: "0x1234",
     * });
     * ```
     *
     * @param {Transaction} tx the transaction to be serialized and signed
     * @param {{serializer?: SerializeTransactionFn}} args options for serialization
     * @param {() => Hex} [args.serializer] an optional serializer function. If not provided, the default `serializeTransaction` function will be used
     * @returns {Promise<string>} a promise that resolves to the serialized transaction with the signature
     */
    signTransaction: <serializer extends SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>, transaction extends Parameters<serializer>[0] = Parameters<serializer>[0]>(transaction: transaction, options?: {
        serializer?: serializer | undefined;
    } | undefined) => Promise<IsNarrowable<TransactionSerialized<GetTransactionType<transaction>>, Hex> extends true ? TransactionSerialized<GetTransactionType<transaction>> : Hex>;
    /**
     * Signs an EIP-7702 Authorization and then returns the authorization with the signature.
     *
     * @example
     * ```ts twoslash
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const tx = await signer.signAuthorization({
     *  contractAddress: "0x1234123412341234123412341234123412341234",
     *  chainId: 1,
     *  nonce: 0,
     * });
     * ```
     *
     * @param {Authorization<number, false>} unsignedAuthorization the authorization to be signed
     * @returns {Promise<Authorization<number, true>> | undefined} a promise that resolves to the authorization with the signature
     */
    signAuthorization: (unsignedAuthorization: Authorization<number, false>) => Promise<Authorization<number, true>>;
    private unpackSignRawMessageBytes;
    /**
     * Unauthenticated call to look up a user's organizationId by email
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const result = await signer.getUser("foo@mail.com");
     * ```
     *
     * @param {string} email the email to lookup
     * @returns {Promise<{orgId: string}>} the organization id for the user if they exist
     */
    getUser: (email: string) => Promise<{
        orgId: string;
    } | null>;
    /**
     * Adds a passkey to the user's account
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const result = await signer.addPasskey()
     * ```
     *
     * @param {CredentialCreationOptions | undefined} params optional parameters for the passkey creation
     * @returns {Promise<string[]>} an array of the authenticator ids added to the user
     */
    addPasskey: (params?: CredentialCreationOptions) => Promise<string[]>;
    /**
     * Used to export the wallet for a given user
     * If the user is authenticated with an Email, this will return a seed phrase
     * If the user is authenticated with a Passkey, this will return a private key
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * // the params passed to this are different based on the specific signer
     * const result = signer.exportWallet()
     * ```
     *
     * @param {unknown} params export wallet parameters
     * @returns {boolean} true if the wallet was exported successfully
     */
    exportWallet: (params: Parameters<(typeof this.inner)["exportWallet"]>[0]) => Promise<boolean>;
    /**
     * This method lets you adapt your AlchemySigner to a viem LocalAccount, which
     * will let you use the signer as an EOA directly.
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const account = signer.toViemAccount();
     * ```
     *
     * @throws if your signer is not authenticated
     * @returns {LocalAccount} a LocalAccount object that can be used with viem's wallet client
     */
    toViemAccount: () => LocalAccount;
    /**
     * Creates a new instance of `SolanaSigner` using the provided inner value.
     * This requires the signer to be authenticated first
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     *
     * const solanaSigner = signer.toSolanaSigner();
     * ```
     *
     * @returns {SolanaSigner} A new instance of `SolanaSigner`
     */
    experimental_toSolanaSigner: () => SolanaSigner;
    private authenticateWithEmail;
    private authenticateWithPasskey;
    private authenticateWithOauth;
    private authenticateWithOtp;
    private handleOauthReturn;
    private getExpirationSeconds;
    private registerListeners;
    private emitNewUserEvent;
}
//# sourceMappingURL=base.d.ts.map