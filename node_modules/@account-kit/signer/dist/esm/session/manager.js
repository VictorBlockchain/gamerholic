import EventEmitter from "eventemitter3";
import { z } from "zod";
import { createJSONStorage, persist, subscribeWithSelector, } from "zustand/middleware";
import { createStore } from "zustand/vanilla";
import { assertNever } from "../utils/typeAssertions.js";
export const DEFAULT_SESSION_MS = 15 * 60 * 1000; // 15 minutes
export const SessionManagerParamsSchema = z.object({
    sessionKey: z.string().default("alchemy-signer-session"),
    storage: z
        .enum(["localStorage", "sessionStorage"])
        .default("localStorage")
        .or(z.custom()),
    expirationTimeMs: z
        .number()
        .default(DEFAULT_SESSION_MS)
        .describe("The time in milliseconds that a session should last before expiring [default: 15 minutes]"),
    client: z.custom(),
});
export class SessionManager {
    constructor(params) {
        Object.defineProperty(this, "sessionKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "eventEmitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "expirationTimeMs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "store", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "clearSessionHandle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "getSessionUser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                const existingSession = this.getSession();
                if (existingSession == null) {
                    return null;
                }
                switch (existingSession.type) {
                    case "email":
                    case "oauth":
                    case "otp": {
                        const connectedEventName = (() => {
                            switch (existingSession.type) {
                                case "email":
                                    return "connectedEmail";
                                case "oauth":
                                    return "connectedOauth";
                                case "otp":
                                    return "connectedOtp";
                            }
                        })();
                        const result = await this.client
                            .completeAuthWithBundle({
                            bundle: existingSession.bundle,
                            orgId: existingSession.user.orgId,
                            authenticatingType: existingSession.type,
                            connectedEventName,
                            idToken: existingSession.user.idToken,
                        })
                            .catch((e) => {
                            console.warn("Failed to load user from session", e);
                            return null;
                        });
                        if (!result) {
                            this.clearSession();
                            return null;
                        }
                        return result;
                    }
                    case "passkey": {
                        // we don't need to do much here if we already have a user
                        // this will setup the client with the user context, but
                        // requests still have to be signed by the user on first request
                        // so this is fine
                        return this.client.lookupUserWithPasskey(existingSession.user);
                    }
                    default:
                        assertNever(existingSession, `Unknown session type: ${existingSession.type}`);
                }
            }
        });
        Object.defineProperty(this, "clearSession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.store.setState({ session: null });
                localStorage.removeItem(`${this.sessionKey}:temporary`);
                if (this.clearSessionHandle) {
                    clearTimeout(this.clearSessionHandle);
                }
            }
        });
        Object.defineProperty(this, "setTemporarySession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (session) => {
                // temporary session must be placed in localStorage so that it can be accessed across tabs
                localStorage.setItem(`${this.sessionKey}:temporary`, JSON.stringify(session));
            }
        });
        Object.defineProperty(this, "getTemporarySession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                // temporary session must be placed in localStorage so that it can be accessed across tabs
                const sessionStr = localStorage.getItem(`${this.sessionKey}:temporary`);
                if (!sessionStr) {
                    return null;
                }
                return JSON.parse(sessionStr);
            }
        });
        Object.defineProperty(this, "on", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (event, listener) => {
                this.eventEmitter.on(event, listener);
                return () => this.eventEmitter.removeListener(event, listener);
            }
        });
        Object.defineProperty(this, "getSession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                const session = this.store.getState().session;
                if (!session) {
                    return null;
                }
                /**
                 * TODO: this isn't really good enough
                 * A user's session could be about to expire and we would still return it
                 *
                 * Instead we should check if a session is about to expire and refresh it
                 * We should revisit this later
                 */
                if (session.expirationDateMs < Date.now()) {
                    this.client.disconnect();
                    this.clearSession();
                    return null;
                }
                this.registerSessionExpirationHandler(session);
                return session;
            }
        });
        Object.defineProperty(this, "setSession", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (session_) => {
                const session = {
                    ...session_,
                    expirationDateMs: Date.now() + this.expirationTimeMs,
                };
                this.registerSessionExpirationHandler(session);
                this.store.setState({ session });
            }
        });
        Object.defineProperty(this, "registerEventListeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.store.subscribe(({ session }) => session, (session, prevSession) => {
                    if (session != null && prevSession == null) {
                        this.eventEmitter.emit("connected", session);
                    }
                    else if (session == null && prevSession != null) {
                        this.eventEmitter.emit("disconnected");
                    }
                });
                const listeners = {
                    connected: undefined,
                    newUserSignup: undefined,
                    authenticating: undefined,
                    connectedEmail: (user, bundle) => this.setSessionWithUserAndBundle({ type: "email", user, bundle }),
                    connectedPasskey: (user) => {
                        const existingSession = this.getSession();
                        if (existingSession != null &&
                            existingSession.type === "passkey" &&
                            existingSession.user.userId === user.userId) {
                            return;
                        }
                        this.setSession({ type: "passkey", user });
                    },
                    connectedOauth: (user, bundle) => this.setSessionWithUserAndBundle({ type: "oauth", user, bundle }),
                    connectedOtp: (user, bundle) => {
                        this.setSessionWithUserAndBundle({ type: "otp", user, bundle });
                    },
                    disconnected: () => this.clearSession(),
                };
                for (const [event, listener] of Object.entries(listeners)) {
                    if (listener) {
                        this.client.on(event, listener);
                    }
                }
                // sync local state if persisted state has changed from another tab
                // only do this in the browser
                // Add a try catch to prevent potential crashes in non-browser environments
                try {
                    if (typeof window !== "undefined" &&
                        typeof window.addEventListener !== "undefined") {
                        window.addEventListener("focus", () => {
                            const oldSession = this.store.getState().session;
                            this.store.persist.rehydrate();
                            const newSession = this.store.getState().session;
                            if ((oldSession?.expirationDateMs ?? 0) < Date.now() ||
                                oldSession?.user.orgId !== newSession?.user.orgId ||
                                oldSession?.user.userId !== newSession?.user.userId) {
                                // Initialize if the user has changed.
                                this.initialize();
                            }
                        });
                    }
                }
                catch (e) {
                    console.error("Error registering event listeners", e);
                }
            }
        });
        Object.defineProperty(this, "registerSessionExpirationHandler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (session) => {
                if (this.clearSessionHandle) {
                    clearTimeout(this.clearSessionHandle);
                }
                this.clearSessionHandle = setTimeout(() => {
                    this.client.disconnect();
                    this.clearSession();
                }, Math.min(session.expirationDateMs - Date.now(), Math.pow(2, 31) - 1));
            }
        });
        Object.defineProperty(this, "setSessionWithUserAndBundle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ({ type, user, bundle, }) => {
                const existingSession = this.getSession();
                if (existingSession != null &&
                    existingSession.type === type &&
                    existingSession.user.userId === user.userId &&
                    // if the bundle is different, then we've refreshed the session
                    // so we need to reset the session
                    existingSession.bundle === bundle) {
                    return;
                }
                this.setSession({ type, user, bundle });
            }
        });
        const { sessionKey, storage: storageType, expirationTimeMs, client, } = SessionManagerParamsSchema.parse(params);
        this.sessionKey = sessionKey;
        const storage = typeof storageType === "string"
            ? storageType === "localStorage"
                ? localStorage
                : sessionStorage
            : storageType;
        this.expirationTimeMs = expirationTimeMs;
        this.client = client;
        this.eventEmitter = new EventEmitter();
        this.store = createStore(subscribeWithSelector(persist(this.getInitialState, {
            name: this.sessionKey,
            storage: createJSONStorage(() => storage),
        })));
        this.registerEventListeners();
    }
    initialize() {
        this.getSessionUser()
            .then((user) => {
            // once we complete auth we can update the state of the session to connected or disconnected
            if (user)
                this.eventEmitter.emit("connected", this.getSession());
            else
                this.eventEmitter.emit("disconnected");
        })
            .finally(() => {
            this.eventEmitter.emit("initialized");
        });
    }
    getInitialState() {
        return {
            session: null,
        };
    }
}
//# sourceMappingURL=manager.js.map