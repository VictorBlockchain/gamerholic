{"version":3,"file":"manager.js","sourceRoot":"","sources":["../../../src/session/manager.ts"],"names":[],"mappings":"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","sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport { z } from \"zod\";\nimport {\n  createJSONStorage,\n  persist,\n  subscribeWithSelector,\n} from \"zustand/middleware\";\nimport { createStore, type Mutate, type StoreApi } from \"zustand/vanilla\";\nimport type { BaseSignerClient } from \"../client/base\";\nimport type {\n  AlchemySignerClientEvent,\n  AlchemySignerClientEvents,\n  User,\n} from \"../client/types\";\nimport { assertNever } from \"../utils/typeAssertions.js\";\nimport type { Session, SessionManagerEvents } from \"./types\";\n\nexport const DEFAULT_SESSION_MS = 15 * 60 * 1000; // 15 minutes\n\nexport const SessionManagerParamsSchema = z.object({\n  sessionKey: z.string().default(\"alchemy-signer-session\"),\n  storage: z\n    .enum([\"localStorage\", \"sessionStorage\"])\n    .default(\"localStorage\")\n    .or(z.custom<Storage>()),\n  expirationTimeMs: z\n    .number()\n    .default(DEFAULT_SESSION_MS)\n    .describe(\n      \"The time in milliseconds that a session should last before expiring [default: 15 minutes]\"\n    ),\n  client: z.custom<BaseSignerClient>(),\n});\n\nexport type SessionManagerParams = z.input<typeof SessionManagerParamsSchema>;\n\ntype SessionState = {\n  session: Session | null;\n};\n\ntype Store = Mutate<\n  StoreApi<SessionState>,\n  [[\"zustand/subscribeWithSelector\", never], [\"zustand/persist\", SessionState]]\n>;\n\ntype TemporarySession = { orgId: string; isNewUser?: boolean };\n\nexport class SessionManager {\n  private sessionKey: string;\n  private client: BaseSignerClient;\n  private eventEmitter: EventEmitter<SessionManagerEvents>;\n  readonly expirationTimeMs: number;\n  private store: Store;\n  private clearSessionHandle: NodeJS.Timeout | null = null;\n\n  constructor(params: SessionManagerParams) {\n    const {\n      sessionKey,\n      storage: storageType,\n      expirationTimeMs,\n      client,\n    } = SessionManagerParamsSchema.parse(params);\n    this.sessionKey = sessionKey;\n    const storage =\n      typeof storageType === \"string\"\n        ? storageType === \"localStorage\"\n          ? localStorage\n          : sessionStorage\n        : storageType;\n    this.expirationTimeMs = expirationTimeMs;\n    this.client = client;\n    this.eventEmitter = new EventEmitter<SessionManagerEvents>();\n\n    this.store = createStore(\n      subscribeWithSelector(\n        persist(this.getInitialState, {\n          name: this.sessionKey,\n          storage: createJSONStorage<SessionState>(() => storage),\n        })\n      )\n    );\n\n    this.registerEventListeners();\n  }\n\n  public getSessionUser = async (): Promise<User | null> => {\n    const existingSession = this.getSession();\n    if (existingSession == null) {\n      return null;\n    }\n\n    switch (existingSession.type) {\n      case \"email\":\n      case \"oauth\":\n      case \"otp\": {\n        const connectedEventName = (() => {\n          switch (existingSession.type) {\n            case \"email\":\n              return \"connectedEmail\";\n            case \"oauth\":\n              return \"connectedOauth\";\n            case \"otp\":\n              return \"connectedOtp\";\n          }\n        })();\n        const result = await this.client\n          .completeAuthWithBundle({\n            bundle: existingSession.bundle,\n            orgId: existingSession.user.orgId,\n            authenticatingType: existingSession.type,\n            connectedEventName,\n            idToken: existingSession.user.idToken,\n          })\n          .catch((e) => {\n            console.warn(\"Failed to load user from session\", e);\n            return null;\n          });\n\n        if (!result) {\n          this.clearSession();\n          return null;\n        }\n\n        return result;\n      }\n      case \"passkey\": {\n        // we don't need to do much here if we already have a user\n        // this will setup the client with the user context, but\n        // requests still have to be signed by the user on first request\n        // so this is fine\n        return this.client.lookupUserWithPasskey(existingSession.user);\n      }\n      default:\n        assertNever(\n          existingSession,\n          `Unknown session type: ${(existingSession as any).type}`\n        );\n    }\n  };\n\n  public clearSession = () => {\n    this.store.setState({ session: null });\n    localStorage.removeItem(`${this.sessionKey}:temporary`);\n\n    if (this.clearSessionHandle) {\n      clearTimeout(this.clearSessionHandle);\n    }\n  };\n\n  public setTemporarySession = (session: TemporarySession) => {\n    // temporary session must be placed in localStorage so that it can be accessed across tabs\n    localStorage.setItem(\n      `${this.sessionKey}:temporary`,\n      JSON.stringify(session)\n    );\n  };\n\n  public getTemporarySession = (): TemporarySession | null => {\n    // temporary session must be placed in localStorage so that it can be accessed across tabs\n    const sessionStr = localStorage.getItem(`${this.sessionKey}:temporary`);\n\n    if (!sessionStr) {\n      return null;\n    }\n\n    return JSON.parse(sessionStr);\n  };\n\n  on = <E extends keyof SessionManagerEvents>(\n    event: E,\n    listener: SessionManagerEvents[E]\n  ) => {\n    this.eventEmitter.on(event, listener as any);\n\n    return () => this.eventEmitter.removeListener(event, listener as any);\n  };\n\n  private getSession = (): Session | null => {\n    const session = this.store.getState().session;\n\n    if (!session) {\n      return null;\n    }\n\n    /**\n     * TODO: this isn't really good enough\n     * A user's session could be about to expire and we would still return it\n     *\n     * Instead we should check if a session is about to expire and refresh it\n     * We should revisit this later\n     */\n    if (session.expirationDateMs < Date.now()) {\n      this.client.disconnect();\n      this.clearSession();\n      return null;\n    }\n\n    this.registerSessionExpirationHandler(session);\n\n    return session;\n  };\n\n  private setSession = (\n    session_:\n      | Omit<\n          Extract<Session, { type: \"email\" | \"oauth\" | \"otp\" }>,\n          \"expirationDateMs\"\n        >\n      | Omit<Extract<Session, { type: \"passkey\" }>, \"expirationDateMs\">\n  ) => {\n    const session = {\n      ...session_,\n      expirationDateMs: Date.now() + this.expirationTimeMs,\n    };\n\n    this.registerSessionExpirationHandler(session);\n\n    this.store.setState({ session });\n  };\n\n  public initialize() {\n    this.getSessionUser()\n      .then((user) => {\n        // once we complete auth we can update the state of the session to connected or disconnected\n        if (user) this.eventEmitter.emit(\"connected\", this.getSession()!);\n        else this.eventEmitter.emit(\"disconnected\");\n      })\n      .finally(() => {\n        this.eventEmitter.emit(\"initialized\");\n      });\n  }\n\n  private getInitialState(): SessionState {\n    return {\n      session: null,\n    };\n  }\n\n  private registerEventListeners = () => {\n    this.store.subscribe(\n      ({ session }) => session,\n      (session, prevSession) => {\n        if (session != null && prevSession == null) {\n          this.eventEmitter.emit(\"connected\", session);\n        } else if (session == null && prevSession != null) {\n          this.eventEmitter.emit(\"disconnected\");\n        }\n      }\n    );\n\n    // Helper type to ensure that a listener is either defined or explicitly\n    // omitted for every event type.\n    type Listeners = {\n      [K in keyof AlchemySignerClientEvents]:\n        | AlchemySignerClientEvents[K]\n        | undefined;\n    };\n\n    const listeners: Listeners = {\n      connected: undefined,\n      newUserSignup: undefined,\n      authenticating: undefined,\n      connectedEmail: (user, bundle) =>\n        this.setSessionWithUserAndBundle({ type: \"email\", user, bundle }),\n      connectedPasskey: (user) => {\n        const existingSession = this.getSession();\n        if (\n          existingSession != null &&\n          existingSession.type === \"passkey\" &&\n          existingSession.user.userId === user.userId\n        ) {\n          return;\n        }\n\n        this.setSession({ type: \"passkey\", user });\n      },\n      connectedOauth: (user, bundle) =>\n        this.setSessionWithUserAndBundle({ type: \"oauth\", user, bundle }),\n      connectedOtp: (user, bundle) => {\n        this.setSessionWithUserAndBundle({ type: \"otp\", user, bundle });\n      },\n      disconnected: () => this.clearSession(),\n    };\n\n    for (const [event, listener] of Object.entries(listeners)) {\n      if (listener) {\n        this.client.on(event as AlchemySignerClientEvent, listener);\n      }\n    }\n\n    // sync local state if persisted state has changed from another tab\n    // only do this in the browser\n    // Add a try catch to prevent potential crashes in non-browser environments\n    try {\n      if (\n        typeof window !== \"undefined\" &&\n        typeof window.addEventListener !== \"undefined\"\n      ) {\n        window.addEventListener(\"focus\", () => {\n          const oldSession = this.store.getState().session;\n          this.store.persist.rehydrate();\n          const newSession = this.store.getState().session;\n          if (\n            (oldSession?.expirationDateMs ?? 0) < Date.now() ||\n            oldSession?.user.orgId !== newSession?.user.orgId ||\n            oldSession?.user.userId !== newSession?.user.userId\n          ) {\n            // Initialize if the user has changed.\n            this.initialize();\n          }\n        });\n      }\n    } catch (e) {\n      console.error(\"Error registering event listeners\", e);\n    }\n  };\n\n  private registerSessionExpirationHandler = (session: Session) => {\n    if (this.clearSessionHandle) {\n      clearTimeout(this.clearSessionHandle);\n    }\n\n    this.clearSessionHandle = setTimeout(() => {\n      this.client.disconnect();\n      this.clearSession();\n    }, Math.min(session.expirationDateMs - Date.now(), Math.pow(2, 31) - 1));\n  };\n\n  private setSessionWithUserAndBundle = ({\n    type,\n    user,\n    bundle,\n  }: {\n    type: \"email\" | \"oauth\" | \"otp\";\n    user: User;\n    bundle: string;\n  }) => {\n    const existingSession = this.getSession();\n    if (\n      existingSession != null &&\n      existingSession.type === type &&\n      existingSession.user.userId === user.userId &&\n      // if the bundle is different, then we've refreshed the session\n      // so we need to reset the session\n      existingSession.bundle === bundle\n    ) {\n      return;\n    }\n\n    this.setSession({ type, user, bundle });\n  };\n}\n"]}