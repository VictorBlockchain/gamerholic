{"version":3,"file":"base.js","sourceRoot":"","sources":["../../src/base.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAkC,MAAM,cAAc,CAAC;AACzE,OAAO,EACL,WAAW,EACX,aAAa,EACb,SAAS,EACT,oBAAoB,GAWrB,MAAM,MAAM,CAAC;AACd,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAC1C,OAAO,EAAE,iBAAiB,EAAsB,MAAM,mBAAmB,CAAC;AAE1E,OAAO,EAAE,qBAAqB,EAAE,MAAM,oBAAoB,CAAC;AAC3D,OAAO,EAAE,WAAW,EAAE,MAAM,iBAAiB,CAAC;AAG9C,OAAO,EAAE,qBAAqB,EAAE,MAAM,aAAa,CAAC;AACpD,OAAO,EAAE,YAAY,EAAE,MAAM,cAAc,CAAC;AAC5C,OAAO,EACL,cAAc,GAEf,MAAM,sBAAsB,CAAC;AAG9B,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACjD,OAAO,EACL,mBAAmB,GAIpB,MAAM,YAAY,CAAC;AACpB,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AA2BxD;;;GAGG;AACH,MAAM,OAAgB,iBAAiB;IAQrC;;;;;;;;;OASG;IACH,YAAY,EACV,MAAM,EACN,aAAa,EACb,YAAY,GACqB;QAnBnC;;;;mBAAqD,gBAAgB;WAAC;QACtE;;;;;WAAe;QACP;;;;;WAA+B;QAC/B;;;;;WAAqB;QAyC7B;;;;;;WAMG;QACH;;;;mBAAK,CACH,KAAQ,EACR,QAAgC,EAChC,EAAE;gBACF,+FAA+F;gBAC/F,gGAAgG;gBAChG,0GAA0G;gBAC1G,QAAQ,KAAK,EAAE,CAAC;oBACd,KAAK,WAAW;wBACd,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CACzB,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,MAAM,EACtB,CAAC,MAAM,EAAE,EAAE,CACT,MAAM,KAAK,mBAAmB,CAAC,SAAS;4BACvC,QAA6C,CAC5C,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,IAAK,CAC5B,EACH,EAAE,eAAe,EAAE,IAAI,EAAE,CAC1B,CAAC;oBACJ,KAAK,cAAc;wBACjB,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CACzB,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,MAAM,EACtB,CAAC,MAAM,EAAE,EAAE,CACT,MAAM,KAAK,mBAAmB,CAAC,YAAY;4BAC1C,QAAgD,EAAE,EACrD,EAAE,eAAe,EAAE,IAAI,EAAE,CAC1B,CAAC;oBACJ,KAAK,eAAe;wBAClB,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CACzB,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,MAAM,EACtB,QAAgD,EAChD,EAAE,eAAe,EAAE,IAAI,EAAE,CAC1B,CAAC;oBACJ,KAAK,cAAc;wBACjB,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CACzB,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,KAAK,EACpB,CAAC,KAAK,EAAE,EAAE,CACP,QAAgD,CAC/C,KAAK,IAAI,SAAS,CACnB,EACH,EAAE,eAAe,EAAE,IAAI,EAAE,CAC1B,CAAC;oBACJ,KAAK,eAAe;wBAClB,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CACzB,CAAC,EAAE,SAAS,EAAE,EAAE,EAAE,CAAC,SAAS,EAC5B,CAAC,SAAS,EAAE,EAAE;4BACZ,IAAI,SAAS;gCAAG,QAAiD,EAAE,CAAC;wBACtE,CAAC,EACD,EAAE,eAAe,EAAE,IAAI,EAAE,CAC1B,CAAC;oBACJ;wBACE,WAAW,CAAC,KAAK,EAAE,sBAAsB,KAAK,EAAE,CAAC,CAAC;gBACtD,CAAC;YACH,CAAC;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA4BG;QACH;;;;mBAAoB,GAAyB,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE;WAAC;QAEvE;;;;;;;;;;;;;;;;;;;;;;;;;;WA0BG;QACH;;;;mBAAsD,YAAY,CAAC,QAAQ,CACzE,gCAAgC,EAChC,KAAK,EAAE,MAAM,EAAE,EAAE;gBACf,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC;gBACxB,MAAM,MAAM,GAAG,CAAC,GAAG,EAAE;oBACnB,QAAQ,IAAI,EAAE,CAAC;wBACb,KAAK,OAAO;4BACV,OAAO,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;wBAC5C,KAAK,SAAS;4BACZ,OAAO,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;wBAC9C,KAAK,OAAO;4BACV,OAAO,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;wBAC5C,KAAK,aAAa;4BAChB,OAAO,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC;wBACxC,KAAK,KAAK;4BACR,OAAO,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;wBAC1C;4BACE,WAAW,CAAC,IAAI,EAAE,sBAAsB,IAAI,EAAE,CAAC,CAAC;oBACpD,CAAC;gBACH,CAAC,CAAC,EAAE,CAAC;gBAEL,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;gBAEnC,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;oBAC5B;;;;;uBAKG;oBACH,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;wBAClB,KAAK,EAAE,WAAW,CAAC,KAAK,CAAC;wBACzB,GAAG,CAAC,IAAI,KAAK,aAAa,IAAI,IAAI,KAAK,OAAO;4BAC5C,CAAC,CAAC,EAAE;4BACJ,CAAC,CAAC,EAAE,MAAM,EAAE,mBAAmB,CAAC,YAAY,EAAE,CAAC;qBAClD,CAAC,CAAC;oBACH,MAAM,KAAK,CAAC;gBACd,CAAC,CAAC,CAAC;YACL,CAAC,CACF;WAAC;QAEM;;;;mBAAwB,CAAC,MAAkB,EAAE,EAAE;gBACrD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC;gBACxB,QAAQ,IAAI,EAAE,CAAC;oBACb,KAAK,OAAO,CAAC,CAAC,CAAC;wBACb,gDAAgD;wBAChD,IAAI,QAAQ,IAAI,MAAM;4BAAE,OAAO;wBAC/B,YAAY,CAAC,UAAU,CAAC;4BACtB,IAAI,EAAE,oBAAoB;4BAC1B,IAAI,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE;yBAC5B,CAAC,CAAC;wBACH,OAAO;oBACT,CAAC;oBACD,KAAK,SAAS,CAAC,CAAC,CAAC;wBACf,MAAM,MAAM,GAAG,CAAC,CAAC,OAAO,IAAI,MAAM,CAAC,IAAI,MAAM,CAAC,SAAS,IAAI,IAAI,CAAC;wBAChE,YAAY,CAAC,UAAU,CAAC;4BACtB,IAAI,EAAE,oBAAoB;4BAC1B,IAAI,EAAE;gCACJ,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,eAAe;6BACpD;yBACF,CAAC,CAAC;wBACH,OAAO;oBACT,CAAC;oBACD,KAAK,OAAO;wBACV,YAAY,CAAC,UAAU,CAAC;4BACtB,IAAI,EAAE,oBAAoB;4BAC1B,IAAI,EAAE;gCACJ,QAAQ,EAAE,OAAO;gCACjB,QAAQ,EAAE,MAAM,CAAC,cAAc;6BAChC;yBACF,CAAC,CAAC;wBACH,MAAM;oBACR,KAAK,aAAa;wBAChB,MAAM;oBACR,KAAK,KAAK;wBACR,YAAY,CAAC,UAAU,CAAC;4BACtB,IAAI,EAAE,oBAAoB;4BAC1B,IAAI,EAAE,EAAE,QAAQ,EAAE,KAAK,EAAE;yBAC1B,CAAC,CAAC;wBACH,MAAM;oBACR;wBACE,WAAW,CAAC,IAAI,EAAE,sBAAsB,IAAI,EAAE,CAAC,CAAC;gBACpD,CAAC;YACH,CAAC;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;WAsBG;QACH;;;;mBAAkC,KAAK,IAAI,EAAE;gBAC3C,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC;YAChC,CAAC;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;;;;;WA0BG;QACH;;;;mBAAiB,KAAK,IAAmB,EAAE;gBACzC,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,CAAC;gBAC/D,IAAI,WAAW,IAAI,IAAI,EAAE,CAAC;oBACxB,OAAO,WAAW,CAAC;gBACrB,CAAC;gBAED,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;YAC7B,CAAC;WAAC;QAEF;;;;WAIG;QACH;;;;mBAA2C,YAAY,CAAC,QAAQ,CAC9D,8BAA8B,EAC9B,KAAK,IAAI,EAAE;gBACT,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;gBAE9C,OAAO,OAAO,CAAC;YACjB,CAAC,CACF;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;;WAuBG;QACH;;;;mBACE,YAAY,CAAC,QAAQ,CAAC,+BAA+B,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE;gBACnE,MAAM,WAAW,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;gBAErC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;gBAE5D,YAAY,CAAC,UAAU,CAAC;oBACtB,IAAI,EAAE,qBAAqB;iBAC5B,CAAC,CAAC;gBAEH,OAAO,MAAM,CAAC;YAChB,CAAC,CAAC;WAAC;QAEL;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA4BG;QACH;;;;mBAKoB,YAAY,CAAC,QAAQ,CACvC,iCAAiC,EACjC,KAAK,EAAE,MAAM,EAAE,EAAE;gBACf,MAAM,WAAW,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;gBAE1C,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;YAChD,CAAC,CACF;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA6BG;QACH;;;;mBAiBI,YAAY,CAAC,QAAQ,CACvB,mCAAmC,EACnC,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE;gBACjB,MAAM,WAAW,GAAG,IAAI,EAAE,UAAU,IAAI,oBAAoB,CAAC;gBAC7D,MAAM,YAAY,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC;gBACrC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,cAAc,CAClD,SAAS,CAAC,YAAY,CAAC,CACxB,CAAC;gBAEF,MAAM,SAAS,GAAG,IAAI,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC;gBAE/D,OAAO,WAAW,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC;YACpC,CAAC,CACF;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;WA2BG;QACH;;;;mBAE4C,YAAY,CAAC,QAAQ,CAC/D,qCAAqC,EACrC,KAAK,EAAE,qBAAqB,EAAE,EAAE;gBAC9B,MAAM,mBAAmB,GAAG,iBAAiB,CAAC,qBAAqB,CAAC,CAAC;gBACrE,MAAM,sBAAsB,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,cAAc,CAC5D,mBAAmB,CACpB,CAAC;gBACF,MAAM,SAAS,GAAG,IAAI,CAAC,yBAAyB,CAAC,sBAAsB,CAAC,CAAC;gBACzE,OAAO,EAAE,GAAG,qBAAqB,EAAE,GAAG,SAAS,EAAE,CAAC;YACpD,CAAC,CACF;WAAC;QAEM;;;;mBAA4B,CAClC,GAAkB,EACC,EAAE;gBACrB,OAAO;oBACL,CAAC,EAAE,SAAS,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC;oBAChC,CAAC,EAAE,SAAS,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;oBAC5C,CAAC,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;iBACpD,CAAC;YACJ,CAAC;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;;WAuBG;QACH;;;;mBACE,YAAY,CAAC,QAAQ,CAAC,2BAA2B,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE;gBACjE,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;gBAEzD,IAAI,MAAM,CAAC,KAAK,IAAI,IAAI,EAAE,CAAC;oBACzB,OAAO,IAAI,CAAC;gBACd,CAAC;gBAED,OAAO;oBACL,KAAK,EAAE,MAAM,CAAC,KAAK;iBACpB,CAAC;YACJ,CAAC,CAAC;WAAC;QAEL;;;;;;;;;;;;;;;;;;;;;;;WAuBG;QACH;;;;mBACE,YAAY,CAAC,QAAQ,CAAC,8BAA8B,EAAE,KAAK,EAAE,MAAM,EAAE,EAAE;gBACrE,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;YAC7C,CAAC,CAAC;WAAC;QAEL;;;;;;;;;;;;;;;;;;;;;;;;;;WA0BG;QACH;;;;mBAEwB,KAAK,EAAE,MAAM,EAAE,EAAE;gBACvC,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;YACzC,CAAC;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;;;WAwBG;QACH;;;;mBAAgB,GAAiB,EAAE;gBACjC,+EAA+E;gBAC/E,0DAA0D;gBAC1D,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,CAAC;oBAC1B,MAAM,IAAI,qBAAqB,EAAE,CAAC;gBACpC,CAAC;gBAED,OAAO,SAAS,CAAC;oBACf,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,EAAG,CAAC,OAAO;oBACtC,WAAW,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC;oBACnD,aAAa,EAAE,CAIb,mBAAgE,EAChE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAyB,mBAAmB,CAAC;oBACpE,eAAe,EAAE,IAAI,CAAC,eAAe;iBACtC,CAAC,CAAC;YACL,CAAC;WAAC;QAEF;;;;;;;;;;;;;;;;;;;;;;;WAuBG;QACH;;;;mBAA8B,GAAiB,EAAE;gBAC/C,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,CAAC;oBAC1B,MAAM,IAAI,qBAAqB,EAAE,CAAC;gBACpC,CAAC;gBAED,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACtC,CAAC;WAAC;QAEM;;;;mBAAwB,KAAK,EACnC,MAA8C,EAC/B,EAAE;gBACjB,IAAI,OAAO,IAAI,MAAM,EAAE,CAAC;oBACtB,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBACtD,MAAM,iBAAiB,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;oBAEtD,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,YAAY;wBACnC,CAAC,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;4BAC7B,KAAK,EAAE,MAAM,CAAC,KAAK;4BACnB,SAAS,EAAE,MAAM,CAAC,SAAS;4BAC3B,iBAAiB;4BACjB,cAAc,EAAE,MAAM,CAAC,cAAc;yBACtC,CAAC;wBACJ,CAAC,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;4BAC7B,IAAI,EAAE,OAAO;4BACb,KAAK,EAAE,MAAM,CAAC,KAAK;4BACnB,SAAS,EAAE,MAAM,CAAC,SAAS;4BAC3B,iBAAiB;4BACjB,cAAc,EAAE,MAAM,CAAC,cAAc;yBACtC,CAAC,CAAC;oBAEP,IAAI,CAAC,cAAc,CAAC,mBAAmB,CAAC;wBACtC,KAAK;wBACL,SAAS,EAAE,CAAC,YAAY;qBACzB,CAAC,CAAC;oBACH,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;wBAClB,MAAM,EAAE,mBAAmB,CAAC,mBAAmB;wBAC/C,KAAK;wBACL,KAAK,EAAE,IAAI;qBACZ,CAAC,CAAC;oBAEH,+DAA+D;oBAC/D,mCAAmC;oBACnC,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;wBACnC,MAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,EAAE,CAC3C,WAAW,EACX,CAAC,OAAO,EAAE,EAAE;4BACV,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;4BACtB,cAAc,EAAE,CAAC;wBACnB,CAAC,CACF,CAAC;oBACJ,CAAC,CAAC,CAAC;gBACL,CAAC;qBAAM,CAAC;oBACN,MAAM,gBAAgB,GAAG,MAAM,CAAC,KAAK;wBACnC,CAAC,CAAC,EAAE,KAAK,EAAE,MAAM,CAAC,KAAK,EAAE;wBACzB,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,CAAC;oBAE9C,IAAI,CAAC,gBAAgB,EAAE,CAAC;wBACtB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;4BAClB,MAAM,EAAE,mBAAmB,CAAC,YAAY;yBACzC,CAAC,CAAC;wBACH,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;oBAC7D,CAAC;oBAED,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC;wBACnD,MAAM,EAAE,MAAM,CAAC,MAAM;wBACrB,KAAK,EAAE,gBAAgB,CAAC,KAAK;wBAC7B,kBAAkB,EAAE,gBAAgB;wBACpC,kBAAkB,EAAE,OAAO;qBAC5B,CAAC,CAAC;oBAEH,sBAAsB;oBACtB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;oBAExC,OAAO,IAAI,CAAC;gBACd,CAAC;YACH,CAAC;WAAC;QAEM;;;;mBAA0B,KAAK,EACrC,IAA8C,EAC/B,EAAE;gBACjB,IAAI,IAAU,CAAC;gBACf,MAAM,eAAe,GAAG,KAAK,IAAI,EAAE;oBACjC,IAAI,OAAO,IAAI,IAAI,EAAE,CAAC;wBACpB,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;wBACpD,OAAO,YAAY,IAAI,IAAI,CAAC;oBAC9B,CAAC;oBAED,OAAO,IAAI,CAAC,SAAS,CAAC;gBACxB,CAAC,CAAC;gBAEF,IAAI,MAAM,eAAe,EAAE,EAAE,CAAC;oBAC5B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,aAAa,CAC3C,IAGC,CACF,CAAC;oBACF,gFAAgF;oBAChF,6BAA6B;oBAC7B,IAAI,GAAG;wBACL,OAAO,EAAE,MAAM,CAAC,OAAQ;wBACxB,MAAM,EAAE,MAAM,CAAC,MAAO;wBACtB,KAAK,EAAE,MAAM,CAAC,KAAK;qBACpB,CAAC;gBACJ,CAAC;qBAAM,CAAC;oBACN,IAAI,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,qBAAqB,EAAE,CAAC;oBAChD,IAAI,CAAC,IAAI,EAAE,CAAC;wBACV,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;4BAClB,MAAM,EAAE,mBAAmB,CAAC,YAAY;yBACzC,CAAC,CAAC;wBACH,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;oBACnC,CAAC;gBACH,CAAC;gBAED,OAAO,IAAI,CAAC;YACd,CAAC;WAAC;QAEM;;;;mBAAwB,KAAK,EACnC,IAA4C,EAC7B,EAAE;gBACjB,MAAM,MAAM,GAAgB;oBAC1B,GAAG,IAAI;oBACP,iBAAiB,EAAE,IAAI,CAAC,oBAAoB,EAAE;iBAC/C,CAAC;gBACF,IAAI,MAAM,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;oBAC/B,OAAO,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC;gBAC9C,CAAC;qBAAM,CAAC;oBACN,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;gBAC3C,CAAC;YACH,CAAC;WAAC;QAEM;;;;mBAAsB,KAAK,EACjC,IAA0C,EAC3B,EAAE;gBACjB,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,CAAC;gBAC9D,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,WAAW,IAAI,EAAE,CAAC;gBAC/C,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;gBACxC,IAAI,CAAC,KAAK,EAAE,CAAC;oBACX,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;gBAChD,CAAC;gBACD,IAAI,CAAC,KAAK,EAAE,CAAC;oBACX,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;gBAChD,CAAC;gBACD,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;oBAChD,KAAK;oBACL,KAAK;oBACL,OAAO,EAAE,IAAI,CAAC,OAAO;oBACrB,iBAAiB,EAAE,IAAI,CAAC,oBAAoB,EAAE;iBAC/C,CAAC,CAAC;gBACH,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC;oBACnD,MAAM;oBACN,KAAK;oBACL,kBAAkB,EAAE,cAAc;oBAClC,kBAAkB,EAAE,KAAK;iBAC1B,CAAC,CAAC;gBAEH,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;gBACjC,IAAI,WAAW,EAAE,CAAC;oBAChB,IAAI,CAAC,cAAc,CAAC,mBAAmB,CAAC;wBACtC,GAAG,WAAW;wBACd,SAAS,EAAE,KAAK;qBACjB,CAAC,CAAC;gBACL,CAAC;gBAED,OAAO,IAAI,CAAC;YACd,CAAC;WAAC;QAEM;;;;mBAAoB,CAAC,EAC3B,MAAM,EACN,KAAK,EACL,OAAO,EACP,SAAS,GACoC,EAAiB,EAAE;gBAChE,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC;oBAC7C,MAAM;oBACN,KAAK;oBACL,kBAAkB,EAAE,gBAAgB;oBACpC,kBAAkB,EAAE,OAAO;oBAC3B,OAAO;iBACR,CAAC,CAAC;gBAEH,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;gBAEjC,OAAO,IAAI,CAAC;YACd,CAAC;WAAC;QAEM;;;;mBAAuB,GAAG,EAAE,CAClC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,gBAAgB,GAAG,IAAI,CAAC;WAAC;QAElD;;;;mBAAoB,GAAG,EAAE;gBAC/B,uEAAuE;gBACvE,WAAW;gBACX,MAAM,SAAS,GAAyB;oBACtC,SAAS,EAAE,CAAC,OAAO,EAAE,EAAE;wBACrB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;4BAClB,IAAI,EAAE,OAAO,CAAC,IAAI;4BAClB,MAAM,EAAE,mBAAmB,CAAC,SAAS;4BACrC,KAAK,EAAE,IAAI;yBACZ,CAAC,CAAC;oBACL,CAAC;oBACD,YAAY,EAAE,GAAG,EAAE;wBACjB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;4BAClB,IAAI,EAAE,IAAI;4BACV,MAAM,EAAE,mBAAmB,CAAC,YAAY;yBACzC,CAAC,CAAC;oBACL,CAAC;oBACD,WAAW,EAAE,GAAG,EAAE;wBAChB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;4BAC9B,MAAM,EAAE,KAAK,CAAC,IAAI;gCAChB,CAAC,CAAC,mBAAmB,CAAC,SAAS;gCAC/B,CAAC,CAAC,mBAAmB,CAAC,YAAY;4BACpC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;yBAC9C,CAAC,CAAC,CAAC;oBACN,CAAC;iBACF,CAAC;gBAEF,KAAK,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC;oBAC1D,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,KAAmC,EAAE,QAAQ,CAAC,CAAC;gBACxE,CAAC;gBAED,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,gBAAgB,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE;oBAC3C,MAAM,MAAM,GAAG,CAAC,GAAG,EAAE;wBACnB,QAAQ,IAAI,EAAE,CAAC;4BACb,KAAK,OAAO;gCACV,OAAO,mBAAmB,CAAC,oBAAoB,CAAC;4BAClD,KAAK,SAAS;gCACZ,OAAO,mBAAmB,CAAC,sBAAsB,CAAC;4BACpD,KAAK,OAAO;gCACV,OAAO,mBAAmB,CAAC,oBAAoB,CAAC;4BAClD,KAAK,KAAK,CAAC;4BACX,KAAK,WAAW;gCACd,OAAO,mBAAmB,CAAC,iBAAiB,CAAC;4BAC/C;gCACE,WAAW,CAAC,IAAI,EAAE,+BAA+B,CAAC,CAAC;wBACvD,CAAC;oBACH,CAAC,CAAC,EAAE,CAAC;oBAEL,+CAA+C;oBAC/C,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,eAAe,EAAE,GAAG,EAAE;wBAClC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;oBAC9B,CAAC,CAAC,CAAC;oBAEH,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;wBAClB,MAAM;wBACN,KAAK,EAAE,IAAI;qBACZ,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC;YACL,CAAC;WAAC;QAEM;;;;mBAAmB,CAAC,SAAmB,EAAE,EAAE;gBACjD,gEAAgE;gBAChE,IAAI,SAAS;oBAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,SAAS,EAAE,CAAC,CAAC;YACpD,CAAC;WAAC;QAv5BA,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,WAAW,CACtB,qBAAqB,CACnB,GAAG,EAAE,CACH,CAAC;YACC,IAAI,EAAE,IAAI;YACV,MAAM,EAAE,mBAAmB,CAAC,YAAY;YACxC,KAAK,EAAE,YAAY,IAAI,IAAI;SACC,CAAC,CAClC,CACF,CAAC;QACF,+DAA+D;QAC/D,oEAAoE;QACpE,2BAA2B;QAC3B,IAAI,CAAC,cAAc,GAAG,IAAI,cAAc,CAAC;YACvC,GAAG,aAAa;YAChB,MAAM,EAAE,IAAI,CAAC,KAAK;SACnB,CAAC,CAAC;QACH,2BAA2B;QAC3B,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,oDAAoD;QACpD,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,CAAC;IACnC,CAAC;CAk4BF;AAED,SAAS,WAAW,CAAC,KAAc;IACjC,OAAO,KAAK,YAAY,KAAK;QAC3B,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE;QAC9C,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,eAAe,EAAE,CAAC;AAClD,CAAC","sourcesContent":["import { takeBytes, type SmartAccountAuthenticator } from \"@aa-sdk/core\";\nimport {\n  hashMessage,\n  hashTypedData,\n  keccak256,\n  serializeTransaction,\n  type GetTransactionType,\n  type Hex,\n  type IsNarrowable,\n  type LocalAccount,\n  type SerializeTransactionFn,\n  type SignableMessage,\n  type TransactionSerializable,\n  type TransactionSerialized,\n  type TypedData,\n  type TypedDataDefinition,\n} from \"viem\";\nimport { toAccount } from \"viem/accounts\";\nimport { hashAuthorization, type Authorization } from \"viem/experimental\";\nimport type { Mutate, StoreApi } from \"zustand\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\nimport { createStore } from \"zustand/vanilla\";\nimport type { BaseSignerClient } from \"./client/base\";\nimport type { OauthConfig, OauthParams, User } from \"./client/types\";\nimport { NotAuthenticatedError } from \"./errors.js\";\nimport { SignerLogger } from \"./metrics.js\";\nimport {\n  SessionManager,\n  type SessionManagerParams,\n} from \"./session/manager.js\";\nimport type { SessionManagerEvents } from \"./session/types\";\nimport type { AuthParams } from \"./signer\";\nimport { SolanaSigner } from \"./solanaSigner.js\";\nimport {\n  AlchemySignerStatus,\n  type AlchemySignerEvent,\n  type AlchemySignerEvents,\n  type ErrorInfo,\n} from \"./types.js\";\nimport { assertNever } from \"./utils/typeAssertions.js\";\n\nexport interface BaseAlchemySignerParams<TClient extends BaseSignerClient> {\n  client: TClient;\n  sessionConfig?: Omit<SessionManagerParams, \"client\">;\n  initialError?: ErrorInfo;\n}\n\ntype AlchemySignerStore = {\n  user: User | null;\n  status: AlchemySignerStatus;\n  error: ErrorInfo | null;\n  otpId?: string;\n  isNewUser?: boolean;\n};\n\ntype UnpackedSignature = {\n  r: `0x${string}`;\n  s: `0x${string}`;\n  v: bigint;\n};\n\ntype InternalStore = Mutate<\n  StoreApi<AlchemySignerStore>,\n  [[\"zustand/subscribeWithSelector\", never]]\n>;\n\n/**\n * Base abstract class for Alchemy Signer, providing authentication and session management for smart accounts.\n * Implements the `SmartAccountAuthenticator` interface and handles various signer events.\n */\nexport abstract class BaseAlchemySigner<TClient extends BaseSignerClient>\n  implements SmartAccountAuthenticator<AuthParams, User, TClient>\n{\n  signerType: \"alchemy-signer\" | \"rn-alchemy-signer\" = \"alchemy-signer\";\n  inner: TClient;\n  private sessionManager: SessionManager;\n  private store: InternalStore;\n\n  /**\n   * Initializes an instance with the provided client and session configuration.\n   * This function sets up the internal store, initializes the session manager,\n   * registers listeners and initializes the session manager to manage session state.\n   *\n   * @param {BaseAlchemySignerParams<TClient>} param0 Object containing the client and session configuration\n   * @param {TClient} param0.client The client instance to be used internally\n   * @param {SessionConfig} param0.sessionConfig Configuration for managing sessions\n   * @param {ErrorInfo | undefined} param0.initialError Error already present on the signer when initialized, if any\n   */\n  constructor({\n    client,\n    sessionConfig,\n    initialError,\n  }: BaseAlchemySignerParams<TClient>) {\n    this.inner = client;\n    this.store = createStore(\n      subscribeWithSelector(\n        () =>\n          ({\n            user: null,\n            status: AlchemySignerStatus.INITIALIZING,\n            error: initialError ?? null,\n          } satisfies AlchemySignerStore)\n      )\n    );\n    // NOTE: it's important that the session manager share a client\n    // with the signer. The SessionManager leverages the Signer's client\n    // to manage session state.\n    this.sessionManager = new SessionManager({\n      ...sessionConfig,\n      client: this.inner,\n    });\n    // register listeners first\n    this.registerListeners();\n    // then initialize so that we can catch those events\n    this.sessionManager.initialize();\n  }\n\n  /**\n   * Allows you to subscribe to events emitted by the signer\n   *\n   * @param {AlchemySignerEvent} event the event to subscribe to\n   * @param {AlchemySignerEvents[AlchemySignerEvent]} listener the function to run when the event is emitted\n   * @returns {() => void} a function to remove the listener\n   */\n  on = <E extends AlchemySignerEvent>(\n    event: E,\n    listener: AlchemySignerEvents[E]\n  ) => {\n    // NOTE: we're using zustand here to handle this because we are able to use the fireImmediately\n    // option which deals with a possible race condition where the listener is added after the event\n    // is fired. In the Client and SessionManager we use EventEmitter because it's easier to handle internally\n    switch (event) {\n      case \"connected\":\n        return this.store.subscribe(\n          ({ status }) => status,\n          (status) =>\n            status === AlchemySignerStatus.CONNECTED &&\n            (listener as AlchemySignerEvents[\"connected\"])(\n              this.store.getState().user!\n            ),\n          { fireImmediately: true }\n        );\n      case \"disconnected\":\n        return this.store.subscribe(\n          ({ status }) => status,\n          (status) =>\n            status === AlchemySignerStatus.DISCONNECTED &&\n            (listener as AlchemySignerEvents[\"disconnected\"])(),\n          { fireImmediately: true }\n        );\n      case \"statusChanged\":\n        return this.store.subscribe(\n          ({ status }) => status,\n          listener as AlchemySignerEvents[\"statusChanged\"],\n          { fireImmediately: true }\n        );\n      case \"errorChanged\":\n        return this.store.subscribe(\n          ({ error }) => error,\n          (error) =>\n            (listener as AlchemySignerEvents[\"errorChanged\"])(\n              error ?? undefined\n            ),\n          { fireImmediately: true }\n        );\n      case \"newUserSignup\":\n        return this.store.subscribe(\n          ({ isNewUser }) => isNewUser,\n          (isNewUser) => {\n            if (isNewUser) (listener as AlchemySignerEvents[\"newUserSignup\"])();\n          },\n          { fireImmediately: true }\n        );\n      default:\n        assertNever(event, `Unknown event type ${event}`);\n    }\n  };\n\n  /**\n   * Prepares the config needed to use popup-based OAuth login. This must be\n   * called before calling `.authenticate` with params `{ type: \"oauth\", mode:\n   * \"popup\" }`, and is recommended to be called on page load.\n   *\n   * This method exists because browsers may prevent popups from opening unless\n   * triggered by user interaction, and so the OAuth config must already have\n   * been fetched at the time a user clicks a social login button.\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * await signer.preparePopupOauth();\n   * ```\n   * @returns {Promise<OauthConfig>} the config which must be loaded before\n   * using popup-based OAuth\n   */\n  preparePopupOauth = (): Promise<OauthConfig> => this.inner.initOauth();\n\n  /**\n   * Authenticate a user with either an email or a passkey and create a session for that user\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const result = await signer.authenticate({\n   *  type: \"email\",\n   *  email: \"foo@mail.com\",\n   * });\n   * ```\n   *\n   * @param {AuthParams} params - undefined if passkey login, otherwise an object with email and bundle to resolve\n   * @returns {Promise<User>} the user that was authenticated\n   */\n  authenticate: (params: AuthParams) => Promise<User> = SignerLogger.profiled(\n    \"BaseAlchemySigner.authenticate\",\n    async (params) => {\n      const { type } = params;\n      const result = (() => {\n        switch (type) {\n          case \"email\":\n            return this.authenticateWithEmail(params);\n          case \"passkey\":\n            return this.authenticateWithPasskey(params);\n          case \"oauth\":\n            return this.authenticateWithOauth(params);\n          case \"oauthReturn\":\n            return this.handleOauthReturn(params);\n          case \"otp\":\n            return this.authenticateWithOtp(params);\n          default:\n            assertNever(type, `Unknown auth type: ${type}`);\n        }\n      })();\n\n      this.trackAuthenticateType(params);\n\n      return result.catch((error) => {\n        /**\n         * 2 things going on here:\n         * 1. for oauth flows we expect the status to remain in authenticating\n         * 2. we do the ternary, because if we explicitly pass in `undefined` for the status, zustand will set the value of status to `undefined`.\n         * However, if we omit it, then it will not override the current value of status.\n         */\n        this.store.setState({\n          error: toErrorInfo(error),\n          ...(type === \"oauthReturn\" || type === \"oauth\"\n            ? {}\n            : { status: AlchemySignerStatus.DISCONNECTED }),\n        });\n        throw error;\n      });\n    }\n  );\n\n  private trackAuthenticateType = (params: AuthParams) => {\n    const { type } = params;\n    switch (type) {\n      case \"email\": {\n        // we just want to track the start of email auth\n        if (\"bundle\" in params) return;\n        SignerLogger.trackEvent({\n          name: \"signer_authnticate\",\n          data: { authType: \"email\" },\n        });\n        return;\n      }\n      case \"passkey\": {\n        const isAnon = !(\"email\" in params) && params.createNew == null;\n        SignerLogger.trackEvent({\n          name: \"signer_authnticate\",\n          data: {\n            authType: isAnon ? \"passkey_anon\" : \"passkey_email\",\n          },\n        });\n        return;\n      }\n      case \"oauth\":\n        SignerLogger.trackEvent({\n          name: \"signer_authnticate\",\n          data: {\n            authType: \"oauth\",\n            provider: params.authProviderId,\n          },\n        });\n        break;\n      case \"oauthReturn\":\n        break;\n      case \"otp\":\n        SignerLogger.trackEvent({\n          name: \"signer_authnticate\",\n          data: { authType: \"otp\" },\n        });\n        break;\n      default:\n        assertNever(type, `Unknown auth type: ${type}`);\n    }\n  };\n\n  /**\n   * Clear a user session and log them out\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * await signer.disconnect();\n   * ```\n   *\n   * @returns {Promise<void>} a promise that resolves when the user is logged out\n   */\n  disconnect: () => Promise<void> = async () => {\n    await this.inner.disconnect();\n  };\n\n  /**\n   * Gets the current logged in user\n   * If a user has an ongoing session, it will use that session and\n   * try to authenticate\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * // throws if not logged in\n   * const user = await signer.getAuthDetails();\n   * ```\n   *\n   * @throws if there is no user logged in\n   * @returns {Promise<User>} the current user\n   */\n  getAuthDetails = async (): Promise<User> => {\n    const sessionUser = await this.sessionManager.getSessionUser();\n    if (sessionUser != null) {\n      return sessionUser;\n    }\n\n    return this.inner.whoami();\n  };\n\n  /**\n   * Retrieves the address of the current user by calling the `whoami` method on `this.inner`.\n   *\n   * @returns {Promise<string>} A promise that resolves to the address of the current user.\n   */\n  getAddress: () => Promise<`0x${string}`> = SignerLogger.profiled(\n    \"BaseAlchemySigner.getAddress\",\n    async () => {\n      const { address } = await this.inner.whoami();\n\n      return address;\n    }\n  );\n\n  /**\n   * Signs a raw message after hashing it.\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const signature = await signer.signMessage(\"Hello, world!\");\n   * ```\n   *\n   * @param {string} msg the message to be hashed and then signed\n   * @returns {Promise<string>} a promise that resolves to the signed message\n   */\n  signMessage: (msg: SignableMessage) => Promise<`0x${string}`> =\n    SignerLogger.profiled(\"BaseAlchemySigner.signMessage\", async (msg) => {\n      const messageHash = hashMessage(msg);\n\n      const result = await this.inner.signRawMessage(messageHash);\n\n      SignerLogger.trackEvent({\n        name: \"signer_sign_message\",\n      });\n\n      return result;\n    });\n\n  /**\n   * Signs a typed message by first hashing it and then signing the hashed message using the `signRawMessage` method.\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const signature = await signer.signTypedData({\n   *  domain: {},\n   *  types: {},\n   *  primaryType: \"\",\n   *  message: {},\n   * });\n   * ```\n   *\n   * @param {TypedDataDefinition<TTypedData, TPrimaryType>} params The parameters for the typed message to be hashed and signed\n   * @returns {Promise<any>} A promise that resolves to the signed message\n   */\n  signTypedData: <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | \"EIP712Domain\" = keyof TTypedData\n  >(\n    params: TypedDataDefinition<TTypedData, TPrimaryType>\n  ) => Promise<Hex> = SignerLogger.profiled(\n    \"BaseAlchemySigner.signTypedData\",\n    async (params) => {\n      const messageHash = hashTypedData(params);\n\n      return this.inner.signRawMessage(messageHash);\n    }\n  );\n\n  /**\n   * Serializes a transaction, signs it with a raw message, and then returns the serialized transaction with the signature.\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const tx = await signer.signTransaction({\n   *  to: \"0x1234\",\n   *  value: \"0x1234\",\n   *  data: \"0x1234\",\n   * });\n   * ```\n   *\n   * @param {Transaction} tx the transaction to be serialized and signed\n   * @param {{serializer?: SerializeTransactionFn}} args options for serialization\n   * @param {() => Hex} [args.serializer] an optional serializer function. If not provided, the default `serializeTransaction` function will be used\n   * @returns {Promise<string>} a promise that resolves to the serialized transaction with the signature\n   */\n  signTransaction: <\n    serializer extends SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n    transaction extends Parameters<serializer>[0] = Parameters<serializer>[0]\n  >(\n    transaction: transaction,\n    options?:\n      | {\n          serializer?: serializer | undefined;\n        }\n      | undefined\n  ) => Promise<\n    IsNarrowable<\n      TransactionSerialized<GetTransactionType<transaction>>,\n      Hex\n    > extends true\n      ? TransactionSerialized<GetTransactionType<transaction>>\n      : Hex\n  > = SignerLogger.profiled(\n    \"BaseAlchemySigner.signTransaction\",\n    async (tx, args) => {\n      const serializeFn = args?.serializer ?? serializeTransaction;\n      const serializedTx = serializeFn(tx);\n      const signatureHex = await this.inner.signRawMessage(\n        keccak256(serializedTx)\n      );\n\n      const signature = this.unpackSignRawMessageBytes(signatureHex);\n\n      return serializeFn(tx, signature);\n    }\n  );\n\n  /**\n   * Signs an EIP-7702 Authorization and then returns the authorization with the signature.\n   *\n   * @example\n   * ```ts twoslash\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const tx = await signer.signAuthorization({\n   *  contractAddress: \"0x1234123412341234123412341234123412341234\",\n   *  chainId: 1,\n   *  nonce: 0,\n   * });\n   * ```\n   *\n   * @param {Authorization<number, false>} unsignedAuthorization the authorization to be signed\n   * @returns {Promise<Authorization<number, true>> | undefined} a promise that resolves to the authorization with the signature\n   */\n  signAuthorization: (\n    unsignedAuthorization: Authorization<number, false>\n  ) => Promise<Authorization<number, true>> = SignerLogger.profiled(\n    \"BaseAlchemySigner.signAuthorization\",\n    async (unsignedAuthorization) => {\n      const hashedAuthorization = hashAuthorization(unsignedAuthorization);\n      const signedAuthorizationHex = await this.inner.signRawMessage(\n        hashedAuthorization\n      );\n      const signature = this.unpackSignRawMessageBytes(signedAuthorizationHex);\n      return { ...unsignedAuthorization, ...signature };\n    }\n  );\n\n  private unpackSignRawMessageBytes = (\n    hex: `0x${string}`\n  ): UnpackedSignature => {\n    return {\n      r: takeBytes(hex, { count: 32 }),\n      s: takeBytes(hex, { count: 32, offset: 32 }),\n      v: BigInt(takeBytes(hex, { count: 1, offset: 64 })),\n    };\n  };\n\n  /**\n   * Unauthenticated call to look up a user's organizationId by email\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const result = await signer.getUser(\"foo@mail.com\");\n   * ```\n   *\n   * @param {string} email the email to lookup\n   * @returns {Promise<{orgId: string}>} the organization id for the user if they exist\n   */\n  getUser: (email: string) => Promise<{ orgId: string } | null> =\n    SignerLogger.profiled(\"BaseAlchemySigner.getUser\", async (email) => {\n      const result = await this.inner.lookupUserByEmail(email);\n\n      if (result.orgId == null) {\n        return null;\n      }\n\n      return {\n        orgId: result.orgId,\n      };\n    });\n\n  /**\n   * Adds a passkey to the user's account\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const result = await signer.addPasskey()\n   * ```\n   *\n   * @param {CredentialCreationOptions | undefined} params optional parameters for the passkey creation\n   * @returns {Promise<string[]>} an array of the authenticator ids added to the user\n   */\n  addPasskey: (params?: CredentialCreationOptions) => Promise<string[]> =\n    SignerLogger.profiled(\"BaseAlchemySigner.addPasskey\", async (params) => {\n      return this.inner.addPasskey(params ?? {});\n    });\n\n  /**\n   * Used to export the wallet for a given user\n   * If the user is authenticated with an Email, this will return a seed phrase\n   * If the user is authenticated with a Passkey, this will return a private key\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * // the params passed to this are different based on the specific signer\n   * const result = signer.exportWallet()\n   * ```\n   *\n   * @param {unknown} params export wallet parameters\n   * @returns {boolean} true if the wallet was exported successfully\n   */\n  exportWallet: (\n    params: Parameters<(typeof this.inner)[\"exportWallet\"]>[0]\n  ) => Promise<boolean> = async (params) => {\n    return this.inner.exportWallet(params);\n  };\n\n  /**\n   * This method lets you adapt your AlchemySigner to a viem LocalAccount, which\n   * will let you use the signer as an EOA directly.\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const account = signer.toViemAccount();\n   * ```\n   *\n   * @throws if your signer is not authenticated\n   * @returns {LocalAccount} a LocalAccount object that can be used with viem's wallet client\n   */\n  toViemAccount = (): LocalAccount => {\n    // if we want this method to be synchronous, then we need to do this check here\n    // otherwise we can use the sessionManager to get the user\n    if (!this.inner.getUser()) {\n      throw new NotAuthenticatedError();\n    }\n\n    return toAccount({\n      address: this.inner.getUser()!.address,\n      signMessage: (msg) => this.signMessage(msg.message),\n      signTypedData: <\n        const typedData extends TypedData | Record<string, unknown>,\n        primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData\n      >(\n        typedDataDefinition: TypedDataDefinition<typedData, primaryType>\n      ) => this.signTypedData<typedData, primaryType>(typedDataDefinition),\n      signTransaction: this.signTransaction,\n    });\n  };\n\n  /**\n   * Creates a new instance of `SolanaSigner` using the provided inner value.\n   * This requires the signer to be authenticated first\n   *\n   * @example\n   * ```ts\n   * import { AlchemyWebSigner } from \"@account-kit/signer\";\n   *\n   * const signer = new AlchemyWebSigner({\n   *  client: {\n   *    connection: {\n   *      rpcUrl: \"/api/rpc\",\n   *    },\n   *    iframeConfig: {\n   *      iframeContainerId: \"alchemy-signer-iframe-container\",\n   *    },\n   *  },\n   * });\n   *\n   * const solanaSigner = signer.toSolanaSigner();\n   * ```\n   *\n   * @returns {SolanaSigner} A new instance of `SolanaSigner`\n   */\n  experimental_toSolanaSigner = (): SolanaSigner => {\n    if (!this.inner.getUser()) {\n      throw new NotAuthenticatedError();\n    }\n\n    return new SolanaSigner(this.inner);\n  };\n\n  private authenticateWithEmail = async (\n    params: Extract<AuthParams, { type: \"email\" }>\n  ): Promise<User> => {\n    if (\"email\" in params) {\n      const existingUser = await this.getUser(params.email);\n      const expirationSeconds = this.getExpirationSeconds();\n\n      const { orgId, otpId } = existingUser\n        ? await this.inner.initEmailAuth({\n            email: params.email,\n            emailMode: params.emailMode,\n            expirationSeconds,\n            redirectParams: params.redirectParams,\n          })\n        : await this.inner.createAccount({\n            type: \"email\",\n            email: params.email,\n            emailMode: params.emailMode,\n            expirationSeconds,\n            redirectParams: params.redirectParams,\n          });\n\n      this.sessionManager.setTemporarySession({\n        orgId,\n        isNewUser: !existingUser,\n      });\n      this.store.setState({\n        status: AlchemySignerStatus.AWAITING_EMAIL_AUTH,\n        otpId,\n        error: null,\n      });\n\n      // We wait for the session manager to emit a connected event if\n      // cross tab sessions are permitted\n      return new Promise<User>((resolve) => {\n        const removeListener = this.sessionManager.on(\n          \"connected\",\n          (session) => {\n            resolve(session.user);\n            removeListener();\n          }\n        );\n      });\n    } else {\n      const temporarySession = params.orgId\n        ? { orgId: params.orgId }\n        : this.sessionManager.getTemporarySession();\n\n      if (!temporarySession) {\n        this.store.setState({\n          status: AlchemySignerStatus.DISCONNECTED,\n        });\n        throw new Error(\"Could not find email auth init session!\");\n      }\n\n      const user = await this.inner.completeAuthWithBundle({\n        bundle: params.bundle,\n        orgId: temporarySession.orgId,\n        connectedEventName: \"connectedEmail\",\n        authenticatingType: \"email\",\n      });\n\n      // fire new user event\n      this.emitNewUserEvent(params.isNewUser);\n\n      return user;\n    }\n  };\n\n  private authenticateWithPasskey = async (\n    args: Extract<AuthParams, { type: \"passkey\" }>\n  ): Promise<User> => {\n    let user: User;\n    const shouldCreateNew = async () => {\n      if (\"email\" in args) {\n        const existingUser = await this.getUser(args.email);\n        return existingUser == null;\n      }\n\n      return args.createNew;\n    };\n\n    if (await shouldCreateNew()) {\n      const result = await this.inner.createAccount(\n        args as Extract<\n          AuthParams,\n          { type: \"passkey\" } & ({ email: string } | { createNew: true })\n        >\n      );\n      // account creation for passkeys returns the whoami response so we don't have to\n      // call it again after signup\n      user = {\n        address: result.address!,\n        userId: result.userId!,\n        orgId: result.orgId,\n      };\n    } else {\n      user = await this.inner.lookupUserWithPasskey();\n      if (!user) {\n        this.store.setState({\n          status: AlchemySignerStatus.DISCONNECTED,\n        });\n        throw new Error(\"No user found\");\n      }\n    }\n\n    return user;\n  };\n\n  private authenticateWithOauth = async (\n    args: Extract<AuthParams, { type: \"oauth\" }>\n  ): Promise<User> => {\n    const params: OauthParams = {\n      ...args,\n      expirationSeconds: this.getExpirationSeconds(),\n    };\n    if (params.mode === \"redirect\") {\n      return this.inner.oauthWithRedirect(params);\n    } else {\n      return this.inner.oauthWithPopup(params);\n    }\n  };\n\n  private authenticateWithOtp = async (\n    args: Extract<AuthParams, { type: \"otp\" }>\n  ): Promise<User> => {\n    const tempSession = this.sessionManager.getTemporarySession();\n    const { orgId, isNewUser } = tempSession ?? {};\n    const { otpId } = this.store.getState();\n    if (!orgId) {\n      throw new Error(\"orgId not found in session\");\n    }\n    if (!otpId) {\n      throw new Error(\"otpId not found in session\");\n    }\n    const { bundle } = await this.inner.submitOtpCode({\n      orgId,\n      otpId,\n      otpCode: args.otpCode,\n      expirationSeconds: this.getExpirationSeconds(),\n    });\n    const user = await this.inner.completeAuthWithBundle({\n      bundle,\n      orgId,\n      connectedEventName: \"connectedOtp\",\n      authenticatingType: \"otp\",\n    });\n\n    this.emitNewUserEvent(isNewUser);\n    if (tempSession) {\n      this.sessionManager.setTemporarySession({\n        ...tempSession,\n        isNewUser: false,\n      });\n    }\n\n    return user;\n  };\n\n  private handleOauthReturn = ({\n    bundle,\n    orgId,\n    idToken,\n    isNewUser,\n  }: Extract<AuthParams, { type: \"oauthReturn\" }>): Promise<User> => {\n    const user = this.inner.completeAuthWithBundle({\n      bundle,\n      orgId,\n      connectedEventName: \"connectedOauth\",\n      authenticatingType: \"oauth\",\n      idToken,\n    });\n\n    this.emitNewUserEvent(isNewUser);\n\n    return user;\n  };\n\n  private getExpirationSeconds = () =>\n    Math.floor(this.sessionManager.expirationTimeMs / 1000);\n\n  private registerListeners = () => {\n    // Declare listeners in an object to typecheck that every event type is\n    // handled.\n    const listeners: SessionManagerEvents = {\n      connected: (session) => {\n        this.store.setState({\n          user: session.user,\n          status: AlchemySignerStatus.CONNECTED,\n          error: null,\n        });\n      },\n      disconnected: () => {\n        this.store.setState({\n          user: null,\n          status: AlchemySignerStatus.DISCONNECTED,\n        });\n      },\n      initialized: () => {\n        this.store.setState((state) => ({\n          status: state.user\n            ? AlchemySignerStatus.CONNECTED\n            : AlchemySignerStatus.DISCONNECTED,\n          ...(state.user ? { error: null } : undefined),\n        }));\n      },\n    };\n\n    for (const [event, listener] of Object.entries(listeners)) {\n      this.sessionManager.on(event as keyof SessionManagerEvents, listener);\n    }\n\n    this.inner.on(\"authenticating\", ({ type }) => {\n      const status = (() => {\n        switch (type) {\n          case \"email\":\n            return AlchemySignerStatus.AUTHENTICATING_EMAIL;\n          case \"passkey\":\n            return AlchemySignerStatus.AUTHENTICATING_PASSKEY;\n          case \"oauth\":\n            return AlchemySignerStatus.AUTHENTICATING_OAUTH;\n          case \"otp\":\n          case \"otpVerify\":\n            return AlchemySignerStatus.AWAITING_OTP_AUTH;\n          default:\n            assertNever(type, \"unhandled authenticating type\");\n        }\n      })();\n\n      // trigger new user event on signer from client\n      this.inner.on(\"newUserSignup\", () => {\n        this.emitNewUserEvent(true);\n      });\n\n      this.store.setState({\n        status,\n        error: null,\n      });\n    });\n  };\n\n  private emitNewUserEvent = (isNewUser?: boolean) => {\n    // assumes that if isNewUser is undefined it is a returning user\n    if (isNewUser) this.store.setState({ isNewUser });\n  };\n}\n\nfunction toErrorInfo(error: unknown): ErrorInfo {\n  return error instanceof Error\n    ? { name: error.name, message: error.message }\n    : { name: \"Error\", message: \"Unknown error\" };\n}\n"]}