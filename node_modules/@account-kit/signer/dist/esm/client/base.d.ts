import { type ConnectionConfig } from "@aa-sdk/core";
import { TurnkeyClient, type TSignedRequest } from "@turnkey/http";
import EventEmitter from "eventemitter3";
import { type Hex } from "viem";
import type { AlchemySignerClientEvents, AuthenticatingEventMetadata, CreateAccountParams, EmailAuthParams, GetOauthProviderUrlArgs, GetWebAuthnAttestationResult, OauthConfig, OauthParams, OtpParams, SignerBody, SignerResponse, SignupResponse, User } from "./types.js";
export interface BaseSignerClientParams {
    stamper: TurnkeyClient["stamper"];
    connection: ConnectionConfig;
    rootOrgId?: string;
    rpId?: string;
}
export type ExportWalletStamper = TurnkeyClient["stamper"] & {
    injectWalletExportBundle(bundle: string): Promise<boolean>;
    injectKeyExportBundle(bundle: string): Promise<boolean>;
    publicKey(): string | null;
};
/**
 * Base class for all Alchemy Signer clients
 */
export declare abstract class BaseSignerClient<TExportWalletParams = unknown> {
    private _user;
    private connectionConfig;
    protected turnkeyClient: TurnkeyClient;
    protected rootOrg: string;
    protected eventEmitter: EventEmitter<AlchemySignerClientEvents>;
    protected oauthConfig: OauthConfig | undefined;
    /**
     * Create a new instance of the Alchemy Signer client
     *
     * @param {BaseSignerClientParams} params the parameters required to create the client
     */
    constructor(params: BaseSignerClientParams);
    /**
     * Asynchronously fetches and sets the OAuth configuration.
     *
     * @returns {Promise<OauthConfig>} A promise that resolves to the OAuth configuration
     */
    initOauth: () => Promise<OauthConfig>;
    protected get user(): User | undefined;
    protected set user(user: User | undefined);
    /**
     * Sets the stamper of the TurnkeyClient.
     *
     * @param {TurnkeyClient["stamper"]} stamper the stamper function to set for the TurnkeyClient
     */
    protected setStamper(stamper: TurnkeyClient["stamper"]): void;
    /**
     * Exports wallet credentials based on the specified type, either as a SEED_PHRASE or PRIVATE_KEY.
     *
     * @param {object} params The parameters for exporting the wallet
     * @param {ExportWalletStamper} params.exportStamper The stamper used for exporting the wallet
     * @param {"SEED_PHRASE" | "PRIVATE_KEY"} params.exportAs Specifies the format for exporting the wallet, either as a SEED_PHRASE or PRIVATE_KEY
     * @returns {Promise<boolean>} A promise that resolves to true if the export is successful
     */
    protected exportWalletInner(params: {
        exportStamper: ExportWalletStamper;
        exportAs: "SEED_PHRASE" | "PRIVATE_KEY";
    }): Promise<boolean>;
    abstract createAccount(params: CreateAccountParams): Promise<SignupResponse>;
    abstract initEmailAuth(params: Omit<EmailAuthParams, "targetPublicKey">): Promise<{
        orgId: string;
        otpId?: string;
    }>;
    abstract completeAuthWithBundle(params: {
        bundle: string;
        orgId: string;
        connectedEventName: keyof AlchemySignerClientEvents;
        authenticatingType: AuthenticatingEventMetadata["type"];
        idToken?: string;
    }): Promise<User>;
    abstract oauthWithRedirect(args: Extract<OauthParams, {
        mode: "redirect";
    }>): Promise<User | never>;
    abstract oauthWithPopup(args: Extract<OauthParams, {
        mode: "popup";
    }>): Promise<User>;
    abstract submitOtpCode(args: Omit<OtpParams, "targetPublicKey">): Promise<{
        bundle: string;
    }>;
    abstract disconnect(): Promise<void>;
    abstract exportWallet(params: TExportWalletParams): Promise<boolean>;
    abstract lookupUserWithPasskey(user?: User): Promise<User>;
    abstract targetPublicKey(): Promise<string>;
    protected abstract getOauthConfig(): Promise<OauthConfig>;
    protected abstract getWebAuthnAttestation(options: CredentialCreationOptions, userDetails?: {
        username: string;
    }): Promise<GetWebAuthnAttestationResult>;
    /**
     * Listen to events emitted by the client
     *
     * @param {AlchemySignerClientEvent} event the event you want to listen to
     * @param {AlchemySignerClientEvents[AlchemySignerClientEvent]} listener the callback function to execute when an event is fired
     * @returns {() => void} a function that will remove the listener when called
     */
    on: <E extends keyof AlchemySignerClientEvents>(event: E, listener: AlchemySignerClientEvents[E]) => () => EventEmitter<AlchemySignerClientEvents, any>;
    /**
     * Handles the creation of authenticators using WebAuthn attestation and the provided options. Requires the user to be authenticated.
     *
     * @param {CredentialCreationOptions} options The options used to create the WebAuthn attestation
     * @returns {Promise<string[]>} A promise that resolves to an array of authenticator IDs
     * @throws {NotAuthenticatedError} If the user is not authenticated
     */
    addPasskey: (options: CredentialCreationOptions) => Promise<string[]>;
    /**
     * Retrieves the current user or fetches the user information if not already available.
     *
     * @param {string} [orgId] optional organization ID, defaults to the user's organization ID
     * @param {string} idToken an OIDC ID token containing additional user information
     * @returns {Promise<User>} A promise that resolves to the user object
     * @throws {Error} if no organization ID is provided when there is no current user
     */
    whoami: (orgId?: string | undefined, idToken?: string) => Promise<User>;
    /**
     * Generates a stamped whoami request for the current user. This request can then be used to call /signer/v1/whoami to get the user information.
     * This is useful if you want to get the user information in a different context like a server. You can pass the stamped request to the server
     * and then call our API to get the user information. Using this stamp is the most trusted way to get the user information since a stamp can only
     * belong to the user who created it.
     *
     * @returns {Promise<TSignedRequest>} a promise that resolves to the "whoami" information for the logged in user
     * @throws {Error} if no organization ID is provided
     */
    stampWhoami: () => Promise<TSignedRequest>;
    /**
     * Looks up information based on an email address.
     *
     * @param {string} email the email address to look up
     * @returns {Promise<any>} the result of the lookup request
     */
    lookupUserByEmail: (email: string) => Promise<{
        orgId: string | null;
    }>;
    /**
     * This will sign a message with the user's private key, without doing any transformations on the message.
     * For SignMessage or SignTypedData, the caller should hash the message before calling this method and pass
     * that result here.
     *
     * @param {Hex} msg the hex representation of the bytes to sign
     * @param {string} mode specify if signing should happen for solana or ethereum
     * @returns {Promise<Hex>} the signature over the raw hex
     */
    signRawMessage: (msg: Hex, mode?: "SOLANA" | "ETHEREUM") => Promise<Hex>;
    /**
     * Returns the current user or null if no user is set.
     *
     * @returns {User | null} the current user object or null if no user is available
     */
    getUser: () => User | null;
    /**
     * Sends a POST request to the given signer route with the specified body and returns the response.
     * Not intended to be used directly, use the specific methods instead on the client instead.
     *
     * @param {SignerRoutes} route The route to which the request should be sent
     * @param {SignerBody<R>} body The request body containing the data to be sent
     * @returns {Promise<SignerResponse<R>>} A promise that resolves to the response from the signer
     */
    request: <R extends "/v1/signup" | "/v1/whoami" | "/v1/auth" | "/v1/lookup" | "/v1/sign-payload" | "/v1/prepare-oauth" | "/v1/otp">(route: R, body: SignerBody<R>) => Promise<SignerResponse<R>>;
    private exportAsSeedPhrase;
    private exportAsPrivateKey;
    /**
     * Returns the authentication url for the selected OAuth Proivder
     *
     * @example
     * ```ts
     *
     * cosnt oauthParams = {
     *  authProviderId: "google",
     *  isCustomProvider: false,
     *  auth0Connection: undefined,
     *  scope: undefined,
     *  claims: undefined,
     *  mode: "redirect",
     *  redirectUrl: "https://your-url-path/oauth-return",
     *  expirationSeconds: 3000
     * };
     *
     * const turnkeyPublicKey = await this.initIframeStamper();
     * const oauthCallbackUrl = this.oauthCallbackUrl;
     * const oauthConfig = this.getOauthConfig() // Optional value for OauthConfig()
     * const usesRelativeUrl = true // Optional value to determine if we use a relative (or absolute) url for the `redirect_url`
     *
     * const oauthProviderUrl = getOauthProviderUrl({
     *  oauthParams,
     *  turnkeyPublicKey,
     *  oauthCallbackUrl
     * })
     *
     * ```
     * @param {GetOauthProviderUrlArgs} args Required. The Oauth provider's auth parameters
     *
     * @returns {Promise<string>} returns the Oauth provider's url
     */
    protected getOauthProviderUrl: (args: GetOauthProviderUrlArgs) => Promise<string>;
    private getOauthConfigForMode;
    protected pollActivityCompletion: <T extends "createOrganizationResult" | "createAuthenticatorsResult" | "createUsersResult" | "createPrivateKeysResult" | "createInvitationsResult" | "acceptInvitationResult" | "signRawPayloadResult" | "createPolicyResult" | "disablePrivateKeyResult" | "deleteUsersResult" | "deleteAuthenticatorsResult" | "deleteInvitationResult" | "deleteOrganizationResult" | "deletePolicyResult" | "createUserTagResult" | "deleteUserTagsResult" | "signTransactionResult" | "deleteApiKeysResult" | "createApiKeysResult" | "createPrivateKeyTagResult" | "deletePrivateKeyTagsResult" | "setPaymentMethodResult" | "activateBillingTierResult" | "deletePaymentMethodResult" | "createApiOnlyUsersResult" | "updateRootQuorumResult" | "updateUserTagResult" | "updatePrivateKeyTagResult" | "createSubOrganizationResult" | "updateAllowedOriginsResult" | "createPrivateKeysResultV2" | "updateUserResult" | "updatePolicyResult" | "createSubOrganizationResultV3" | "createWalletResult" | "createWalletAccountsResult" | "initUserEmailRecoveryResult" | "recoverUserResult" | "setOrganizationFeatureResult" | "removeOrganizationFeatureResult" | "exportPrivateKeyResult" | "exportWalletResult" | "createSubOrganizationResultV4" | "emailAuthResult" | "exportWalletAccountResult">(activity: Awaited<ReturnType<(typeof this.turnkeyClient)["getActivity"]>>["activity"], organizationId: string, resultKey: T) => Promise<NonNullable<{
        createOrganizationResult?: {
            organizationId: string;
        } | undefined;
        createAuthenticatorsResult?: {
            authenticatorIds: string[];
        } | undefined;
        createUsersResult?: {
            userIds: string[];
        } | undefined;
        createPrivateKeysResult?: {
            privateKeyIds: string[];
        } | undefined;
        createInvitationsResult?: {
            invitationIds: string[];
        } | undefined;
        acceptInvitationResult?: {
            invitationId: string;
            userId: string;
        } | undefined;
        signRawPayloadResult?: {
            r: string;
            s: string;
            v: string;
        } | undefined;
        createPolicyResult?: {
            policyId: string;
        } | undefined;
        disablePrivateKeyResult?: {
            privateKeyId: string;
        } | undefined;
        deleteUsersResult?: {
            userIds: string[];
        } | undefined;
        deleteAuthenticatorsResult?: {
            authenticatorIds: string[];
        } | undefined;
        deleteInvitationResult?: {
            invitationId: string;
        } | undefined;
        deleteOrganizationResult?: {
            organizationId: string;
        } | undefined;
        deletePolicyResult?: {
            policyId: string;
        } | undefined;
        createUserTagResult?: {
            userTagId: string;
            userIds: string[];
        } | undefined;
        deleteUserTagsResult?: {
            userTagIds: string[];
            userIds: string[];
        } | undefined;
        signTransactionResult?: {
            signedTransaction: string;
        } | undefined;
        deleteApiKeysResult?: {
            apiKeyIds: string[];
        } | undefined;
        createApiKeysResult?: {
            apiKeyIds: string[];
        } | undefined;
        createPrivateKeyTagResult?: {
            privateKeyTagId: string;
            privateKeyIds: string[];
        } | undefined;
        deletePrivateKeyTagsResult?: {
            privateKeyTagIds: string[];
            privateKeyIds: string[];
        } | undefined;
        setPaymentMethodResult?: {
            lastFour: string;
            cardHolderName: string;
            cardHolderEmail: string;
        } | undefined;
        activateBillingTierResult?: {
            productId: string;
        } | undefined;
        deletePaymentMethodResult?: {
            paymentMethodId: string;
        } | undefined;
        createApiOnlyUsersResult?: {
            userIds: string[];
        } | undefined;
        updateRootQuorumResult?: {
            [key: string]: unknown;
        } | undefined;
        updateUserTagResult?: {
            userTagId: string;
        } | undefined;
        updatePrivateKeyTagResult?: {
            privateKeyTagId: string;
        } | undefined;
        createSubOrganizationResult?: {
            subOrganizationId: string;
        } | undefined;
        updateAllowedOriginsResult?: {
            [key: string]: unknown;
        } | undefined;
        createPrivateKeysResultV2?: {
            privateKeys: {
                privateKeyId?: string | undefined;
                addresses?: {
                    format?: "ADDRESS_FORMAT_UNCOMPRESSED" | "ADDRESS_FORMAT_COMPRESSED" | "ADDRESS_FORMAT_ETHEREUM" | "ADDRESS_FORMAT_SOLANA" | "ADDRESS_FORMAT_COSMOS" | undefined;
                    address?: string | undefined;
                }[] | undefined;
            }[];
        } | undefined;
        updateUserResult?: {
            userId: string;
        } | undefined;
        updatePolicyResult?: {
            policyId: string;
        } | undefined;
        createSubOrganizationResultV3?: {
            subOrganizationId: string;
            privateKeys: {
                privateKeyId?: string | undefined;
                addresses?: {
                    format?: "ADDRESS_FORMAT_UNCOMPRESSED" | "ADDRESS_FORMAT_COMPRESSED" | "ADDRESS_FORMAT_ETHEREUM" | "ADDRESS_FORMAT_SOLANA" | "ADDRESS_FORMAT_COSMOS" | undefined;
                    address?: string | undefined;
                }[] | undefined;
            }[];
        } | undefined;
        createWalletResult?: {
            walletId: string;
            addresses: string[];
        } | undefined;
        createWalletAccountsResult?: {
            addresses: string[];
        } | undefined;
        initUserEmailRecoveryResult?: {
            userId: string;
        } | undefined;
        recoverUserResult?: {
            authenticatorId: string[];
        } | undefined;
        setOrganizationFeatureResult?: {
            features: {
                name?: "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY" | "FEATURE_NAME_WEBAUTHN_ORIGINS" | "FEATURE_NAME_EMAIL_AUTH" | "FEATURE_NAME_EMAIL_RECOVERY" | undefined;
                value?: string | undefined;
            }[];
        } | undefined;
        removeOrganizationFeatureResult?: {
            features: {
                name?: "FEATURE_NAME_ROOT_USER_EMAIL_RECOVERY" | "FEATURE_NAME_WEBAUTHN_ORIGINS" | "FEATURE_NAME_EMAIL_AUTH" | "FEATURE_NAME_EMAIL_RECOVERY" | undefined;
                value?: string | undefined;
            }[];
        } | undefined;
        exportPrivateKeyResult?: {
            privateKeyId: string;
            exportBundle: string;
        } | undefined;
        exportWalletResult?: {
            walletId: string;
            exportBundle: string;
        } | undefined;
        createSubOrganizationResultV4?: {
            subOrganizationId: string;
            wallet?: {
                walletId: string;
                addresses: string[];
            } | undefined;
        } | undefined;
        emailAuthResult?: {
            userId: string;
            apiKeyId: string;
        } | undefined;
        exportWalletAccountResult?: {
            address: string;
            exportBundle: string;
        } | undefined;
    }[T]>>;
    /**
     * Turnkey requires the nonce in the id token to be in this format.
     *
     * @param {string} turnkeyPublicKey key from a Turnkey iframe
     * @returns {string} nonce to be used in OIDC
     */
    protected getOauthNonce: (turnkeyPublicKey: string) => string;
}
