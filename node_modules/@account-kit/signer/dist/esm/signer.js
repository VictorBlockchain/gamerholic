import { z } from "zod";
import { BaseAlchemySigner } from "./base.js";
import { AlchemySignerClientParamsSchema, AlchemySignerWebClient, } from "./client/index.js";
import { SessionManagerParamsSchema } from "./session/manager.js";
export const AlchemySignerParamsSchema = z
    .object({
    client: z
        .custom()
        .or(AlchemySignerClientParamsSchema),
})
    .extend({
    sessionConfig: SessionManagerParamsSchema.omit({
        client: true,
    }).optional(),
});
/**
 * A SmartAccountSigner that can be used with any SmartContractAccount
 */
export class AlchemyWebSigner extends BaseAlchemySigner {
    /**
     * Initializes an instance with the provided Alchemy signer parameters after parsing them with a schema.
     *
     * @example
     * ```ts
     * import { AlchemyWebSigner } from "@account-kit/signer";
     *
     * const signer = new AlchemyWebSigner({
     *  client: {
     *    connection: {
     *      rpcUrl: "/api/rpc",
     *    },
     *    iframeConfig: {
     *      iframeContainerId: "alchemy-signer-iframe-container",
     *    },
     *  },
     * });
     * ```
     *
     * @param {AlchemySignerParams} params The parameters for the Alchemy signer, including the client and session configuration
     */
    constructor(params) {
        const { sessionConfig, ...params_ } = AlchemySignerParamsSchema.parse(params);
        let client;
        if ("connection" in params_.client) {
            client = new AlchemySignerWebClient(params_.client);
        }
        else {
            client = params_.client;
        }
        const { emailBundle, oauthBundle, oauthOrgId, oauthError, idToken, isSignup, } = getAndRemoveQueryParams({
            emailBundle: "bundle",
            // We don't need this, but we still want to remove it from the URL.
            emailOrgId: "orgId",
            oauthBundle: "alchemy-bundle",
            oauthOrgId: "alchemy-org-id",
            oauthError: "alchemy-error",
            idToken: "alchemy-id-token",
            isSignup: "aa-is-signup",
        });
        const initialError = oauthError != null
            ? { name: "OauthError", message: oauthError }
            : undefined;
        super({ client, sessionConfig, initialError });
        const isNewUser = isSignup === "true";
        this.signerType = "alchemy-signer";
        if (emailBundle) {
            this.authenticate({
                type: "email",
                bundle: emailBundle,
                isNewUser,
            });
        }
        else if (oauthBundle && oauthOrgId && idToken) {
            this.authenticate({
                type: "oauthReturn",
                bundle: oauthBundle,
                orgId: oauthOrgId,
                idToken,
                isNewUser,
            });
        }
    }
}
/**
 * Reads and removes the specified query params from the URL.
 *
 * @param {T} keys object whose values are the query parameter keys to read and
 * remove
 * @returns {{ [K in keyof T]: string | undefined }} object with the same keys
 * as the input whose values are the values of the query params.
 */
function getAndRemoveQueryParams(keys) {
    const url = new URL(window.location.href);
    const result = {};
    let foundQueryParam = false;
    for (const [key, param] of Object.entries(keys)) {
        const value = url.searchParams.get(param) ?? undefined;
        foundQueryParam || (foundQueryParam = value != null);
        result[key] = value;
        url.searchParams.delete(param);
    }
    if (foundQueryParam) {
        window.history.replaceState(window.history.state, "", url.toString());
    }
    return result;
}
//# sourceMappingURL=signer.js.map